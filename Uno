/* 
  Sketch generated by the Arduino IoT Cloud Thing "R4WIFIF_code"
  https://create.arduino.cc/cloud/things/a160e85f-ef98-4302-a052-bea6dae573a2 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String messageToArdunio;
  String messageToServer;
  float lastRPos;
  float lastXPos;
  float lastYPos;
  float lastZPos;
  int compleation;
  int exeSpeed;
  bool enabledSteppers;
  bool status;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
const int wifiLedPin  = 2;  // existing LED for Wi-Fi status
const int commLedPin  = 3;  // new LED for comms-handshake

enum CommState { C_IDLE, C_WAITING_ACK, C_SENDING_DATA };
static CommState commState     = C_IDLE;
static unsigned long commTimer = 0;
const unsigned long COMM_ACK_TIMEOUT = 200;  // ms


String pendingMessage = "";

// Handshake tracking
bool handshakeDone         = false;
unsigned long lastPingTime = 0;
const unsigned long PING_INTERVAL = 500; // ms

// Blink the comms LED
void blinkComms() {
  digitalWrite(commLedPin, HIGH);
  delay(50);
  digitalWrite(commLedPin, LOW);
}

void setup() {
  // LEDs
  pinMode(wifiLedPin, OUTPUT);
  pinMode(commLedPin, OUTPUT);
  digitalWrite(wifiLedPin, HIGH);   // Wi-Fi off initially
  digitalWrite(commLedPin, HIGH);   // Comms LED on until handshake

  delay(1500);

  Serial.begin(9600);
  Serial1.begin(9600);

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  
  // Keep Cloud alive
  ArduinoCloud.update();

    // If disconnected, force LED on and skip everything else
  if (! ArduinoCloud.connected()) {
    digitalWrite(wifiLedPin, HIGH);
    return;  
  }

  // Connected turn LED off by default
  digitalWrite(wifiLedPin, LOW);

  // 2) Startup two-way “AAreadAA” handshake
 if (Serial1.available()) {
  String in = Serial1.readStringUntil('\n');
  in.trim();
  lastPingTime = millis();  // mark as active

  if (in.equals("AAreadAA")) {
    // always reply, even if already handshaken
    Serial1.println("AAreadAA");
    handshakeDone = true;
    digitalWrite(commLedPin, LOW);
  } else if (in.startsWith("U")) {
    parseUMessage(in.substring(1));
  } else {
    messageToServer = in;
  }
}

// — 2) If not handshaken, ping regularly
if (!handshakeDone && millis() - lastPingTime >= PING_INTERVAL) {
  Serial1.println("AAreadAA");
  lastPingTime = millis();
  return;  // wait for handshake before continuing
}

// — 3) If handshaken, but it's been too long → reset handshake
if (handshakeDone && millis() - lastPingTime >= PING_INTERVAL * 5) {
  handshakeDone = false;
  digitalWrite(commLedPin, HIGH);
  return;
}

  if (handshakeDone && pendingMessage.length() > 0) {
  Serial1.println(pendingMessage);
  pendingMessage = "";
  blinkComms();  // optional visual feedback
}
}

void parseUMessage(String recivedMessage) {

    recivedMessage = recivedMessage.substring(1);  // Ignore first character

    int sectionCount = 0;
    int startIndex = 0;
    int endIndex = recivedMessage.indexOf(';');

    while (endIndex != -1) {
        sectionCount++;

        String temp = recivedMessage.substring(startIndex, endIndex);

        // Handle the section based on its order
        if (temp.length() != 0 && temp.charAt(0) != 'E') {

                if (sectionCount == 1) {
            status = temp.toInt();
        }
                if (sectionCount == 2) {
            enabledSteppers = temp.toInt();
        }
                if (sectionCount == 4) {
           exeSpeed = temp.toInt();
        }
                if (sectionCount == 5) {
           compleation = temp.toInt();
        }
                if (sectionCount == 6) {
           lastZPos = temp.toInt();
        }
                if (sectionCount == 7) {
          status = temp.toInt();
        }
                if (sectionCount == 8) {
          status = temp.toInt();
        }
                if (sectionCount == 9) {
          status = temp.toInt();
        }
                if (sectionCount == 10) {
          status = temp.toInt();
        }

        startIndex = endIndex + 1;
        endIndex = recivedMessage.indexOf(';', startIndex);
             
      }
    }
  }

// ———————————————————————————————————————————————————————————
// Cloud callbacks queue into pendingMessage
// ———————————————————————————————————————————————————————————

void onMessageToArdunioChange()  {
  pendingMessage = messageToArdunio;
}
/*
  Since MessageToServer is READ_WRITE variable, onMessageToServerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMessageToServerChange()  {
  // Add your code here to act upon MessageToServer change
}
/*
  Since PileColor is READ_WRITE variable, onPileColorChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPileColorChange()  {
  // Add your code here to act upon PileColor change
}
/*
  Since LastRPos is READ_WRITE variable, onLastRPosChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLastRPosChange()  {
  // Add your code here to act upon LastRPos change
}
/*
  Since LastXPos is READ_WRITE variable, onLastXPosChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLastXPosChange()  {
  // Add your code here to act upon LastXPos change
}
/*
  Since LastYPos is READ_WRITE variable, onLastYPosChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLastYPosChange()  {
  // Add your code here to act upon LastYPos change
}
/*
  Since LastZPos is READ_WRITE variable, onLastZPosChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLastZPosChange()  {
  // Add your code here to act upon LastZPos change
}
/*
  Since Compleation is READ_WRITE variable, onCompleationChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCompleationChange()  {
  // Add your code here to act upon Compleation change
}
/*
  Since ExeSpeed is READ_WRITE variable, onExeSpeedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onExeSpeedChange()  {
  // Add your code here to act upon ExeSpeed change
}
/*
  Since PilePerMinute is READ_WRITE variable, onPilePerMinuteChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPilePerMinuteChange()  {
  // Add your code here to act upon PilePerMinute change
}
/*
  Since EnabledSteppers is READ_WRITE variable, onEnabledSteppersChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onEnabledSteppersChange()  {
  // Add your code here to act upon EnabledSteppers change
}
/*
  Since Status is READ_WRITE variable, onStatusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onStatusChange()  {
  // Add your code here to act upon Status change
}

/*
  Since WatchMotor is READ_WRITE variable, onWatchMotorChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWatchMotorChange()  {
  // Add your code here to act upon WatchMotor change
}
