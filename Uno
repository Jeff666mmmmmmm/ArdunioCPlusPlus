/*
  R4WIFIF_code – chunked sender
  - Accepts Cloud messages that start with '$' (optionally '$S...')
  - Stores body in buffer
  - Once per second, sends one '|' delimited chunk to Serial1
  - Each sent chunk is prefixed with 'S'
  - If any chunk > 64 chars -> send "E$LEN>64" and clear buffer
*/

#include "thingProperties.h"
#include <WiFiS3.h>

const int wifiLedPin  = 3;
const int commLedPin  = 2;

static String chunkBuffer = "";          // holds remaining unsent payload (no leading $/S)
static unsigned long lastChunkSendMs = 0;
const unsigned long CHUNK_INTERVAL_MS = 1000;
const size_t MAX_CHUNK_LEN = 64;

void blinkComms() {
  digitalWrite(commLedPin, HIGH);
  delay(80);
  digitalWrite(commLedPin, LOW);
}

void setup() {
  pinMode(wifiLedPin, OUTPUT);
  pinMode(commLedPin, OUTPUT);
  digitalWrite(wifiLedPin, HIGH);
  digitalWrite(commLedPin, HIGH);

  delay(500);

  Serial.begin(9600);
  Serial1.begin(9600);
  Serial1.setTimeout(10);  // keep reads non-blocking-ish

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  Serial.print("WiFi.fw: "); Serial.println(WiFi.firmwareVersion());
  Serial.print("WiFi.status at boot: "); Serial.println(WiFi.status());
}

void loop() {
  ArduinoCloud.update();

  if (!ArduinoCloud.connected()) {
    digitalWrite(wifiLedPin, LOW);
    delay(80);
    digitalWrite(wifiLedPin, HIGH);
    return;
  }
  digitalWrite(wifiLedPin, LOW);

  // we don't transmit anything opportunistically—only timed chunking from chunkBuffer
  unsigned long now = millis();
  if (chunkBuffer.length() > 0 && (now - lastChunkSendMs >= CHUNK_INTERVAL_MS)) {
    lastChunkSendMs = now;

    // Find next token up to first '|'
    int bar = chunkBuffer.indexOf('|');
    String token;
    if (bar < 0) {
      token = chunkBuffer;
      chunkBuffer = "";
    } else {
      token = chunkBuffer.substring(0, bar);
      // remove token + delimiter from buffer
      chunkBuffer = chunkBuffer.substring(bar + 1);
    }

    token.trim();
    if (token.length() == 0) {
      // skip empty tokens (caused by "||")
      return;
    }

    if (token.length() > MAX_CHUNK_LEN) {
      // error: chunk too long -> wipe buffer
      Serial.println("E$LEN>64");
      chunkBuffer = "";
      blinkComms();
      return;
    }

    // send with required 'S' prefix so the other Arduino expects/accepts it
    Serial1.println("S" + token);
    Serial.println("S"+token);
    blinkComms();
  }

  // (Optional) If you also listen to Serial1 for handshakes or other traffic,
  // keep it here — but DO NOT forward anything else out from this backend.
  if (Serial1.available()) {
    String in = Serial1.readStringUntil('\n');
    in.trim();
    if (in.length()) {
      Serial.print("[Serial1<-] ");
      Serial.println(in);
      messageToServer = in;
    }
  }
}

// ---------------- Cloud callback ----------------

void onMessageToArdunioChange() {
  // Accept only strings that start with '$'
  const String &msg = messageToArdunio;
  Serial.println(msg);

      // ignore anything that isn't a payload bundle
  if (msg.length() == 0) {
    return;
  }
  // If other message to ardunio
    if (msg.charAt(0) != 'S') {
      String msg1 = msg;
       msg1.trim();
    Serial1.println(msg1);
    return;
  }

  // Strip leading '$' and an immediate 'S'/'s' if present: "$S..." -> "..."
  int start = 1;
  if (msg.length() >= 2 && (msg.charAt(1) == '$')) {
    start = 2;
  }

  chunkBuffer = msg.substring(start);
  chunkBuffer.trim();

  // Reset timer so first chunk can go out soon
  lastChunkSendMs = 0;

  Serial.print("[Cloud] buffered payload len=");
  Serial.println(chunkBuffer.length());
}

// ---------------- Unused generated callbacks (left empty intentionally) ----------------
void onMessageToServerChange() {}
void onPileColorChange() {}
void onLastRPosChange() {}
void onLastXPosChange() {}
void onLastYPosChange() {}
void onLastZPosChange() {}
void onCompleationChange() {}
void onExeSpeedChange() {}
void onPilePerMinuteChange() {}
void onEnabledSteppersChange() {}
void onStatusChange() {}
void onWatchMotorChange() {}
