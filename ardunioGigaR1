// Insertion of files
// ==============================

// Include arduino functions
#include <Arduino.h>

// Include multiple processor functions
#include <RPC.h>

// Communication Variables
// ==============================

// Delay between important messages
const unsigned long ImportantMsgDelay = 2500;

// Last Important message out
unsigned long LastImportantMsg = millis();

// Last sending out of data in milliseconds
unsigned long lastDataSend = millis();

// Is script error paused
bool scriptErrorPaused = false;

// Last saved reason for error
String lastErrorReason = "";

// Is script delayed and waiting for input
bool scriptWait = false;

// Function Variables
// ==============================

// Are fans currently running
bool heatSinkFansRunning = false;

// Last fan change update
unsigned long lastFanChange = millis();

// Action notification light
const int goodLight = 51;

// Communication notification light
const int commLight = 52;

// Error notification light
const int errorLight = 53;

// All Motor Variables
// ==============================

// Min step delay
const float minStepDelay = 2.5;

// Max step delay
const int maxStepDelay = 8;

// Motor steps per inch
const int arduinoMotorStepsPerInch = 127;

// Motor enable pin
const int ENABLE_PIN_MOTOR = 22;

// Motor uptime in milliseconds
volatile int MotorUpTime = 0;

// Motor downtime in milliseconds
volatile int MotorDownTime = 0;

// Last time update in milliseconds
unsigned long LastMotorRunUpdate = 0;

// gun motor enable pin
const int ENABLE_PIN_GUNMOTOR = 23;

// Fan enable pin
const int ENABLE_PIN_FAN = 47;

// X Motor specific Variables
// ==============================

// H-bridge pin outs
const int IN1X = 25;
const int IN2X = 27;
const int IN3X = 29;
const int IN4X = 31;

// Axis direction configuration
const int X_SIGN = -1;

// Lever input polarity
const bool X_LEVER_ACTIVE_HIGH = true;

// Pressure Leaver minimum position
const int PressureLever_ReadX = 35;

// Step delay in milliseconds
int stepDelayX = 3;

// Last step recorded
int lastStepX = 0;

// Max step distance
const int maxXStep = 36 * arduinoMotorStepsPerInch;

// Position from 0
volatile int motorStepPositionX = 0;

// Total Steps Completed
volatile int motorStepCompleationX = 0;

// Y Motor specific Variables
// ==============================

// H-bridge pin outs
const int IN1Y = 39;
const int IN2Y = 41;
const int IN3Y = 43;
const int IN4Y = 45;

// Axis direction configuration
const int Y_SIGN = -1;

// Lever input polarity
const bool Y_LEVER_ACTIVE_HIGH = true;

// Pressure Leaver minimum position
const int PressureLever_ReadY = 37;

// Step delay milliseconds
int stepDelayY = 3;

// Last step recorded
int lastStepY = 0;

// Max step distance
const int maxYStep = 36 * arduinoMotorStepsPerInch;

// Position from 0
volatile int motorStepPositionY = 0;

// Total Steps Completed
volatile int motorStepCompleationY = 0;

// Z Motor specific Variables
// ==============================

// H-bridge pins
const int IN1Z = 24;
const int IN2Z = 26;
const int IN3Z = 28;
const int IN4Z = 30;

// Axis direction configuration
const int Z_SIGN = -1;

// Lever input polarity
const bool Z_LEVER_ACTIVE_HIGH = true;

// Pressure Leaver minimum position
const int PressureLever_ReadZ = 34;

// Step delay in milliseconds
int stepDelayZ = 3;

// Last step recorded
int lastStepZ = 0;

// Max step distance
const int maxZStep = 36 * arduinoMotorStepsPerInch;

// Position from 0
volatile int motorStepPositionZ = 0;

// Total Steps Completed
volatile int motorStepCompleationZ = 0;

// R Motor specific Variables
// ==============================

// H-bridge pins
const int IN1R = 38;
const int IN2R = 40;
const int IN3R = 42;
const int IN4R = 44;

// Axis direction configuration
const int R_SIGN = -1;

// Magnetic detector
const int R_MAGNETIC_PIN = A1;

// R step delay live in milliseconds
int stepDelayR = 5;

// R last step recorded
int lastStepR = 0;

// Target rotation for head
volatile int targetHeadAngleDeg = 0;

// Current known rotation of head
int currentRotationOfHead = 0;

// R Position from 0
volatile int motorStepPositionR = 0;
int lastReadMagneticEncoder = 0;
volatile int motorStepCompleationR = 0;

// ==============================

// Stepper motor sequence for 4-step drive
const int steps[4][4] = {
  { 1, 0, 1, 0 },  // Step 1
  { 0, 1, 1, 0 },  // Step 2
  { 0, 1, 0, 1 },  // Step 3
  { 1, 0, 0, 1 }   // Step 4
};

// ==============================

// Data to run immediately
String commandNow = "";

unsigned long lastPayloadRequestTime = 0;
String lastPayloadRequested = "";  // avoid duplicate requests

// Set aside room for payloads
const int numCommands = 25;
String commands[numCommands];

// Completed Executing Info
int currentCommandNumber = 1;
int currentCommandStringExecution = 0;
int currentCommandExecution = 0;
static bool g_isImmediateExec = false;

String maxPayloadToRequest = "";
bool finishedCurrentGcode = true;

// String to send out to cloud
String msgForSerial = "";
int lastMessageSentUniqueID = 0;

// ==============================

// Put the firmware into script-error mode and light the error LED
void enterScriptError(const String& reason, const String& out = "") {
  scriptErrorPaused = true;
  lastErrorReason = reason.length() ? reason : "executeCommand failed";
  digitalWrite(errorLight, HIGH);
  // Only set an outbound message if caller passed one and we don't already have one queued
  if (out.length() && msgForSerial == "") {
    msgForSerial = out;
  }
  DBG("SCRIPT-ERR", "paused: " + lastErrorReason);
}

// Return if base 62
static inline bool isBase62Char(char c) {
  return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}

// Return if posible base 62
static inline bool looksBase62Id(const String& s, int off) {
  if (off < 0 || off + 5 > s.length()) return false;
  for (int i = 0; i < 5; ++i) {
    if (!isBase62Char(s.charAt(off + i))) return false;
  }
  return true;
}

// Map desired numeric delta -> which physical stepper direction to call
static inline int dirForDelta(long delta, int SIGN) {
  if (delta == 0) return 0;
  // If we need numeric position to increase (delta>0),
  // that's "forward" iff SIGN>0; else it's "backward".
  return ((delta > 0) == (SIGN > 0)) ? +1 : -1;
}

// Read Analog 1 magnetic encoder
long readRMagneticEncoder(uint8_t samples = 8) {
  long acc = 0;
  for (uint8_t i = 0; i < samples; ++i) {
    acc += analogRead(R_MAGNETIC_PIN);
  }
  return acc / samples;
}

// Convert decimal to base 62
String decimalToBase62(unsigned long number, int minLength = 5) {
  const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  String result = "";

  if (number == 0) {
    result = "0";
  } else {
    while (number > 0) {
      result = chars[number % 62] + result;
      number /= 62;
    }
  }

  // Pad with leading zeros if needed
  while ((int)result.length() < minLength) {
    result = "0" + result;
  }

  return result;
}

// Decode base 62 to decimal
unsigned long base62ToDecimal(String input) {
  const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  unsigned long result = 0;

  for (int i = 0; i < input.length(); ++i) {
    char c = input.charAt(i);
    const char* pos = strchr(chars, c);

    if (pos == nullptr) {
      // Invalid character; handle however you like
      return 0;
    }

    int value = pos - chars;
    result = result * 62 + value;
  }

  return result;
}

// ==============================
// Debug helpers

#ifndef DEBUG_SERIAL_BAUD
#define DEBUG_SERIAL_BAUD 115200
#endif
#define TXDBG(msg) \
  Serial.print("[TX] "); \
  Serial.println(msg)

// prefix logs with millis and a short tag
void DBG(const String& tag, const String& msg) {
  Serial.print('[');
  Serial.print(millis());
  Serial.print("] ");
  Serial.print(tag);
  Serial.print(": ");
  Serial.println(msg);
}

// Returns the 5-character payload ID prefix for the command at the given index
String payloadIdAt(int idx) {
  if (idx < 0) return "-----";
  if (idx >= 16) return "-----";
  if (commands[idx].length() >= 5) return commands[idx].substring(0, 5);
  return "-----";
}

// Quick snapshot of slot occupancy and pointers
void dumpCommandSlots() {
  Serial.println(F("---- SLOTS ----"));
  for (int i = 0; i < numCommands; i++) {
    String id = (commands[i].length() >= 5) ? commands[i].substring(0, 5) : "-----";
    Serial.print(i);
    Serial.print(": ");
    Serial.print(id);
    if (i == currentCommandStringExecution) Serial.print("  <CUR>");
    Serial.println();
  }
  Serial.print(F("currentCommandNumber="));
  Serial.println(currentCommandNumber);
  Serial.print(F("currentCommandExecution="));
  Serial.println(currentCommandExecution);
  Serial.println(F("----------------"));
}

// Print raw payload for a given 5-char id; returns slot or -1
int dumpPayloadById(const String& id62) {
  int slot = findSlotById62(id62);
  if (slot < 0) {
    DBG("PAYLOAD", "id=" + id62 + " not in slots");
    return -1;
  }
  DBG("PAYLOAD", "id=" + id62 + " slot=" + String(slot) + " raw='" + commands[slot] + "'");
  return slot;
}

// Pretty dump for the *current* payload (the one runCommands is executing)
void dumpCurrentPayload() {
  String needId = decimalToBase62((unsigned long)currentCommandNumber, 5);
  int slot = dumpPayloadById(needId);
  if (slot >= 0) {
    // Also show which command index we’re about to execute
    DBG("PAYLOAD-CURSOR", "next section index=" + String(currentCommandExecution));
  }
}

// Convert numeric 0–61 to base-62 char
static inline char toBase62Digit(uint8_t v) {
  static const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  return chars[(v <= 61) ? v : 0];
}

// Convert base-62 char back to numeric 0–61 (returns 0xFF if invalid)
static inline uint8_t fromBase62Digit(char c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'Z') return 10 + (c - 'A');
  if (c >= 'a' && c <= 'z') return 36 + (c - 'a');
  return 0xFF;
}

// Pack up to 5 booleans into a single base-62 character.
char packBooleansToBase62(
  bool b1, bool b2 = false, bool b3 = false, bool b4 = false, bool b5 = false) {
  uint8_t bits =
    ((b1 ? 1 : 0) << 0) | ((b2 ? 1 : 0) << 1) | ((b3 ? 1 : 0) << 2) | ((b4 ? 1 : 0) << 3) | ((b5 ? 1 : 0) << 4);
  return toBase62Digit(bits);
}

// Unpack a base-62 character back into 5 booleans.
void unpackBooleansFromBase62(
  char c, bool& b1, bool& b2, bool& b3, bool& b4, bool& b5) {
  uint8_t bits = fromBase62Digit(c);
  if (bits == 0xFF) bits = 0;
  b1 = bits & (1 << 0);
  b2 = bits & (1 << 1);
  b3 = bits & (1 << 2);
  b4 = bits & (1 << 3);
  b5 = bits & (1 << 4);
}

// ==============================

// Return true if the given lever is currently pressed
static inline bool leverPressedAxis(int pin, bool activeHigh) {
  int v = digitalRead(pin);
  return activeHigh ? (v == HIGH) : (v == LOW);
}

// Function to energize X stepper motor coils
bool stepMotorX(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  step = (step % 4 + 4) % 4;
  int direction = (step - lastStepX + 4) % 4;  // 1 = forward (toward lever), 3 = backward (away)

  bool moved = false;

  if (direction == 1) {  // forward (TOWARD lever) -> numeric position DECREASES
    if (!ignoreBounds && leverPressedAxis(PressureLever_ReadX, X_LEVER_ACTIVE_HIGH)) {
      msgForSerial = "IX lever pressed, block fwd";
      lastErrorReason = "X lever pressed; forward step blocked";
      return false;  // soft block: do not approach an already-pressed lever
    }
    if (ignoreBounds || motorStepPositionX > 0) {
      motorStepPositionX--;  // ↓ position toward lever
      moved = true;
    } else {
      msgForSerial = "EMotor X OOB fwd pos=" + String(motorStepPositionX);
      lastErrorReason = "Step Motor X ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }

  } else if (direction == 3) {  // backward (AWAY from lever) -> numeric position INCREASES
    if (ignoreBounds || motorStepPositionX < maxXStep) {
      motorStepPositionX++;  // ↑ position away from lever
      moved = true;
    } else {
      msgForSerial = "EMotor X OOB back pos=" + String(motorStepPositionX) + " max=" + String(maxXStep);
      lastErrorReason = "Step Motor X ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }

  } else if (direction == 2) {
    msgForSerial = "EMotor X invalid phase jump";
    lastErrorReason = "Invalid X phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return false;
  }

  // drive coils
  digitalWrite(IN1X, steps[step][0]);
  digitalWrite(IN2X, steps[step][1]);
  digitalWrite(IN3X, steps[step][2]);
  digitalWrite(IN4X, steps[step][3]);

  lastStepX = step;
  if (moved) motorStepCompleationX++;
  return true;
}

// Order Motor X forwards
bool stepMotorXForward(bool ignoreBounds) {
  int nextStep = (lastStepX + 1) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Order Motor X backwards
bool stepMotorXBackward(bool ignoreBounds) {
  int nextStep = (lastStepX + 3) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Function to energize Z stepper motor coils
bool stepMotorZ(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  step = (step % 4 + 4) % 4;
  int direction = (step - lastStepZ + 4) % 4;  // 1=fwd (toward lever), 3=back (away)

  bool moved = false;

  if (direction == 1) {  // forward (TOWARD lever) -> numeric position DECREASES
    if (!ignoreBounds && leverPressedAxis(PressureLever_ReadZ, Z_LEVER_ACTIVE_HIGH)) {
      msgForSerial = "IZ lever pressed, block fwd";
      lastErrorReason = "Z lever pressed; forward step blocked";
      return false;  // soft block
    }
    if (ignoreBounds || motorStepPositionZ > 0) {
      motorStepPositionZ--;  // ↓ position toward lever
      moved = true;
    } else {
      msgForSerial = "EMotor Z OOB fwd pos=" + String(motorStepPositionZ);
      lastErrorReason = "Step Motor Z ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }

  } else if (direction == 3) {  // backward (AWAY from lever) -> numeric position INCREASES
    if (ignoreBounds || motorStepPositionZ < maxZStep) {
      motorStepPositionZ++;  // ↑ position away from lever
      moved = true;
    } else {
      msgForSerial = "EMotor Z OOB back pos=" + String(motorStepPositionZ) + " max=" + String(maxZStep);
      lastErrorReason = "Step Motor Z ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }

  } else if (direction == 2) {
    msgForSerial = "EMotor Z invalid phase jump";
    lastErrorReason = "Invalid Z phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return false;
  }

  // drive coils
  digitalWrite(IN1Z, steps[step][0]);
  digitalWrite(IN2Z, steps[step][1]);
  digitalWrite(IN3Z, steps[step][2]);
  digitalWrite(IN4Z, steps[step][3]);

  lastStepZ = step;
  if (moved) motorStepCompleationZ++;
  return true;
}

// Order Motor Z forwards
bool stepMotorZForward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 1) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Order Motor Z backwards
bool stepMotorZBackward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 3) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Change motor heat sink fans status
void runFans(bool run) {

  // Fans on, requested off
  if (heatSinkFansRunning && !run) {

    // Fans currently running
    heatSinkFansRunning = false;
    digitalWrite(ENABLE_PIN_FAN, LOW);

    // Change update
    lastFanChange = millis();

    // Fans off, requested to run
  } else if (!heatSinkFansRunning && run) {

    // Fans currently running
    heatSinkFansRunning = true;
    digitalWrite(ENABLE_PIN_FAN, HIGH);

    // Change update
    lastFanChange = millis();
  }
}

// Motors Running Status
void stepMotorsActivated(bool run) {

  // Update uptime or downtime based on the motor state
  if (run) {
    digitalWrite(ENABLE_PIN_MOTOR, HIGH);
    runFans(true);

    // Increment uptime
    MotorUpTime += (millis() - LastMotorRunUpdate);
    -LastMotorRunUpdate;
  } else {
    digitalWrite(ENABLE_PIN_MOTOR, LOW);
    runFans(false);

    // Increment downtime
    MotorUpTime += (millis() - LastMotorRunUpdate);
    -LastMotorRunUpdate;
  }

  // Update lastMotorRunUpdate to the current time
  LastMotorRunUpdate = millis();
  ;
}

// two-digit "ms" field: "XY" -> X.Y milliseconds (0.0..9.9)
static inline float parseTwoDigitMs(const String& s, int off = 0) {
  int d0 = s.charAt(off) - '0';
  int d1 = s.charAt(off + 1) - '0';
  if (d0 < 0 || d0 > 9 || d1 < 0 || d1 > 9) return 0.0f;
  return d0 + d1 * 0.1f;
}

// Return slot index [0..numCommands-1] that holds the payload id62, or -1 if absent
int findSlotById62(const String& id62) {
  for (int i = 0; i < numCommands; i++) {
    // Each command string starts with its 5-character base62 ID
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == id62) {
      return i;
    }
  }
  return -1;
}

// Count empty slots across ALL 20
int countEmptySlotsAll() {
  int c = 0;
  for (int i = 0; i < numCommands; i++)
    if (commands[i].length() == 0) c++;
  return c;
}

// Generic homing routine for one axis
static bool homeOneAxis(
  const char* axisName,
  int leverPin,
  int maxStep,
  int stepsPerInch,
  int stepDelayMs,
  bool (*stepForward)(bool),
  bool (*stepBackward)(bool),
  volatile int& stepPositionVar,
  volatile int& stepCompletionVar) {
  // Ensure motors are powered while homing
  stepMotorsActivated(true);

  // Approach the switch (ignore bounds while seeking home)
  for (int i = 0; i < round(maxStep + (stepsPerInch)*2); ++i) {
    if (!stepForward(true)) {
      msgForSerial = String("EHome ") + axisName + " step fwd fail";
      lastErrorReason = String("Home ") + axisName + " step forward failed";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
    delay(stepDelayMs);

    bool isZ = (leverPin == PressureLever_ReadZ);
    bool pressed = leverPressedAxis(leverPin, isZ ? Z_LEVER_ACTIVE_HIGH : X_LEVER_ACTIVE_HIGH);
    if (pressed) {
      // We hit the lever. Back off ~1 inch to clear it first…
      for (int j = 0; j < round(0.5 * stepsPerInch); ++j) {
        if (!stepBackward(true)) {
          msgForSerial = String("EHome ") + axisName + " backoff fail";
          lastErrorReason = String("Home ") + axisName + " backoff failed";
          scriptErrorPaused = true;
          digitalWrite(errorLight, HIGH);
          return false;
        }
        delay(stepDelayMs);
      }

      pressed = leverPressedAxis(leverPin, isZ ? Z_LEVER_ACTIVE_HIGH : X_LEVER_ACTIVE_HIGH);
      if (pressed) {

        msgForSerial = String("EHome ") + axisName + " lever stuck";
        lastErrorReason = String("Home ") + axisName + " lever still HIGH after backoff";
        scriptErrorPaused = true;
        digitalWrite(errorLight, HIGH);
        return false;
      }

      // ✅ Define zero *here*, at the cleared position.
      stepPositionVar = 0;
      stepCompletionVar = 0;
      return true;
    }
  }

  // Never triggered within travel
  msgForSerial = String("EFailed to home ") + axisName;
  lastErrorReason = String("Home ") + axisName + " never triggered lever";
  scriptErrorPaused = true;
  digitalWrite(errorLight, HIGH);
  return false;
}

// Homes Stepper Motors; returns true only if all succeed.
bool homeStepperMotorsPositions() {

  // Use your existing per-axis delays
  int useDelayX = stepDelayX > 0 ? stepDelayX : 4;
  int useDelayZ = stepDelayZ > 0 ? stepDelayZ : 4;

  bool okX = homeOneAxis(
    "X",
    PressureLever_ReadX,
    maxXStep,
    arduinoMotorStepsPerInch,
    useDelayX,
    &stepMotorXForward,
    &stepMotorXBackward,
    motorStepPositionX,
    motorStepCompleationX);

  // X fail
  if (!okX) return false;

  bool okZ = homeOneAxis(
    "Z",
    PressureLever_ReadZ,
    maxZStep,
    arduinoMotorStepsPerInch,
    useDelayZ,
    &stepMotorZForward,
    &stepMotorZBackward,
    motorStepPositionZ,
    motorStepCompleationZ);

  // Z fail
  if (!okZ) return false;

  // If all run, return as successful
  return (okX && okZ);
}

// --- Request policy helpers ---
static inline unsigned long b62u(const String& s) {
  if (s.length() == 0) return 0xFFFFFFFFUL;  // treat empty as "no limit" later
  return base62ToDecimal(s);
}

static inline bool slotHasId62(const String& id62) {
  return findSlotById62(id62) >= 0;
}

// True if the next payload IDs are all absent
bool nextSlotsMissing() {
  for (int i = 0; i < 5; ++i) {
    String id62 = decimalToBase62((unsigned long)(currentCommandNumber + i), 5);
    if (slotHasId62(id62)) return false;  // found one present -> not "all missing"
  }
  return true;
}

// Find the closest missing payload id (>= currentCommandNumber), not exceeding maxN.
// If windowOnly is true, only look in [current, current+5]; otherwise keep going.
bool findClosestMissingId62(String& outId62, unsigned long maxN, bool windowOnly) {
  unsigned long cur = (unsigned long)currentCommandNumber;
  unsigned long limit = windowOnly ? (cur + 5) : maxN;

  if (maxN != 0xFFFFFFFFUL && limit > maxN) limit = maxN;
  for (unsigned long n = cur; n <= limit; ++n) {
    String id62 = decimalToBase62(n, 5);
    if (!slotHasId62(id62)) {
      outId62 = id62;
      return true;
    }
  }
  return false;
}

// Main gate for deciding if we should queue a request now
bool requestNextIfPolicy() {
  if (finishedCurrentGcode) return false;                                    // nothing more to fetch
  if (msgForSerial != "") return false;                                      // don't clobber a pending msg
  if (millis() - lastPayloadRequestTime <= ImportantMsgDelay) return false;  // rate limit

  const int empties = countEmptySlotsAll();
  const bool lotsAheadAllMissing = nextSlotsMissing();
  if (!(empties >= 14 || lotsAheadAllMissing)) return false;

  unsigned long maxN = b62u(maxPayloadToRequest);
  if (maxN == 0xFFFFFFFFUL) {
    // No cap provided; set a very large ceiling
    maxN = 0xFFFFFFF0UL;
  }

  // Try to find the closest missing within the next-6 window first…
  String needId;
  bool found = findClosestMissingId62(needId, maxN, /*windowOnly=*/true);

  // If buffer is roomy search farther ahead up to maxN.
  if (!found && empties >= 14) {
    found = findClosestMissingId62(needId, maxN, /*windowOnly=*/false);
  }

  if (!found) {
    // Nothing missing in range up to maxN → either we’re loaded with all remaining
    // payloads or we’re past max. Don’t request.
    return false;
  }

  // Construct and queue the specific request
  String constructed = "R" + needId;

  msgForSerial = constructed;
  lastPayloadRequested = constructed;
  lastPayloadRequestTime = millis();
  DBG("REQ", "policy OK -> " + constructed);
  return true;
}


// Execute individual command
bool executeCommand(String givenString) {
  // Task of command
  char task = givenString[0];

  // Info for task to be executed, if any
  String taskInfo = givenString.substring(1);

  DBG("EXEC-IN", "task=" + String(givenString[0]) + " info='" + taskInfo + "'" + " id=" + decimalToBase62((unsigned long)currentCommandNumber, 5) + " cmd#" + String(currentCommandExecution));

  // Pause script due to error
  if (task == 'A') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);

    scriptErrorPaused = true;
    lastErrorReason = "Forced Into Error state by command";
    digitalWrite(errorLight, HIGH);
    return true;
  }

  // Unpause script due to error
  if (task == 'B') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);

    scriptErrorPaused = false;
    digitalWrite(errorLight, LOW);
    return true;
  }

  // Put script into wait mode
  if (task == 'C') {

    digitalWrite(goodLight, HIGH);

    scriptWait = true;
    return true;
  }

  // Remove script from wait mode
  if (task == 'D') {

    digitalWrite(goodLight, LOW);

    scriptWait = false;
    return true;
  }

  // Step motor X forward
  if (task == 'E') return stepMotorXForward(false);
  // Step motor X backward
  if (task == 'F') return stepMotorXBackward(false);
  // Step motor Z forward
  if (task == 'G') return stepMotorZForward(false);
  // Step motor Z backward
  if (task == 'H') return stepMotorZBackward(false);

  // Step motor X by relative step count
  if (task == 'I') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorXForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorXBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Step motor Z by relative step count
  if (task == 'J') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorZForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorZBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Hold all motor positions with force
  if (task == 'K') {
    if (taskInfo.length() != 0) {
      msgForSerial = "EK-length " + String(taskInfo);
      return false;
    }
    stepMotorsActivated(true);
    return true;
  }

  // Move motor X to specific step (LddXXXX where dd=ms, XXXX=base62 width 4)
  if (task == 'L') {
    if (taskInfo.length() != 6) {
      msgForSerial = "EL-length " + String(taskInfo);
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base62ToDecimal(taskInfo.substring(2, 6));  // 4 chars, 0..1,679,615
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxXStep) {
      while (motorStepPositionX != StepPosition) {
        long delta = (long)StepPosition - (long)motorStepPositionX;
        int dir = dirForDelta(delta, X_SIGN);
        if (dir > 0) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        delay(tempdelay);
      }

      return true;
    } else {
      msgForSerial = "EMotor X OOB (" + String(StepPosition) + ") max (" + String(maxXStep) + ")";
      return false;
    }
  }

  // Move motor Z to specific step (MddXXXX where dd=ms, XXXX=base62 width 4)
  if (task == 'M') {
    if (taskInfo.length() != 6) {
      msgForSerial = "EM-length " + String(taskInfo);
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base62ToDecimal(taskInfo.substring(2, 6));
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxZStep) {
      while (motorStepPositionZ != StepPosition) {
        long delta = (long)StepPosition - (long)motorStepPositionZ;
        int dir = dirForDelta(delta, Z_SIGN);
        if (dir > 0) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        delay(tempdelay);
      }

      return true;
    } else {
      msgForSerial = "EMotor Z OOB (" + String(StepPosition) + ") max (" + String(maxZStep) + ")";
      return false;
    }
  }

  // Ping back to server
  if (task == 'N') {
    if (taskInfo.length() != 0) {
      msgForSerial = "EN-length " + String(taskInfo);
      return false;
    }
    msgForSerial = "P(" + String(millis()) + ")";
    return true;
  }

  // Duel move X and Y motors O + [delay(2)] + [signPair(1)] + [x62(3)] + [z62(3)]
  if (task == 'O') {
    if (taskInfo.length() != 9) {
      msgForSerial = "EO-length " + String(taskInfo);
      digitalWrite(errorLight, HIGH);
      return false;
    }

    float baseDelay = parseTwoDigitMs(taskInfo, 0);  // 0.0..9.9 ms
    char signPair = taskInfo.charAt(2);              // should be '0' for absolute
    if (signPair != '0') {
      // Not fatal—just note it. We ignore sign for absolute moves.
      DBG("O-WARN", "signPair != '0' (absolute mode)");
    }

    unsigned long xAbsUL = base62ToDecimal(taskInfo.substring(3, 6));  // width 3
    unsigned long zAbsUL = base62ToDecimal(taskInfo.substring(6, 9));  // width 3

    // Clamp within machine limits (your travel is tiny vs 62^3-1)
    long targetX = (long)min((unsigned long)maxXStep, xAbsUL);
    long targetZ = (long)min((unsigned long)maxZStep, zAbsUL);

    // Compute the required relative steps from current position
    long xSteps = targetX - (long)motorStepPositionX;
    long zSteps = targetZ - (long)motorStepPositionZ;

    // Bounds check (projected final positions)
    long projX = motorStepPositionX + xSteps;
    long projZ = motorStepPositionZ + zSteps;
    if (projX < 0 || projX > maxXStep || projZ < 0 || projZ > maxZStep) {
      msgForSerial =
        "EO-OOB x:" + String(motorStepPositionX) + "->" + String(projX) + " z:" + String(motorStepPositionZ) + "->" + String(projZ);
      lastErrorReason = "O move out of bounds";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }

    // Parallel stepping so both axes finish together
    int ax = abs(xSteps), az = abs(zSteps);
    int maxSteps = (ax > az) ? ax : az;

    float xDelay = (ax == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)ax);
    float zDelay = (az == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)az);

    unsigned long nextX = millis(), nextZ = nextX;
    int remX = ax, remZ = az;

    // Use sign mapping so "forward" matches your configured axis convention
    int dirXCmd = dirForDelta(xSteps, X_SIGN);  // +1 => call stepMotorXForward
    int dirZCmd = dirForDelta(zSteps, Z_SIGN);  // +1 => call stepMotorZForward
    DBG("O-Z",
        "cur=" + String(motorStepPositionZ) + " tgt=" + String(targetZ) + " delta=" + String(zSteps) + " dirCmd=" + String(dirZCmd));
    while (remX > 0 || remZ > 0) {
      unsigned long now = millis();

      if (remX > 0 && now >= nextX) {
        if (dirXCmd > 0) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        remX--;
        nextX = now + (unsigned long)(xDelay);
      }

      if (remZ > 0 && now >= nextZ) {
        if (dirZCmd > 0) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        remZ--;
        nextZ = now + (unsigned long)(zDelay);
      }

      delay(1);
    }

    return true;
  }

  // Rotate head
  if (task == 'P') {
    if (taskInfo.length() != 2) {
      msgForSerial = "EP-length " + String(taskInfo);
      return false;
    }
    unsigned long angUL = base62ToDecimal(taskInfo);
    int angle = (int)(angUL % 360UL);
    targetHeadAngleDeg = angle;

    return true;
  }

  // Home motors
  if (task == 'Q') {
    if (taskInfo.length() != 0) {
      msgForSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    return homeStepperMotorsPositions();
  }

  // Tool up
  if (task == 'R') {
    if (taskInfo.length() != 0) {
      msgForSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    return true;
  }

  // Tool down
  if (task == 'S') {
    if (taskInfo.length() != 0) {
      msgForSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    return true;
  }

  // Reset script for new gcode
  if (task == 'T') {
    // Expect exactly 5 chars: the last payload ID (base62) we're allowed to request
    if (taskInfo.length() != 5) {
      msgForSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    // Optional: sanity check looks like base62
    if (!looksBase62Id(taskInfo, 0)) {
      msgForSerial = "EQ-badid " + taskInfo;
      return false;
    }

    // --- Reset run-state ---
    finishedCurrentGcode = false;
    scriptErrorPaused = false;
    scriptWait = false;

    // Set the global cap (DON'T shadow it locally)
    maxPayloadToRequest = taskInfo;  // e.g., "00AbZ" means don't request beyond this id

    // Reset execution pointers
    currentCommandNumber = 1;
    currentCommandExecution = 0;
    currentCommandStringExecution = -1;

    // Clear any in-flight/queued requests & slots
    lastPayloadRequested = "";
    lastPayloadRequestTime = 0;
    for (int i = 0; i < numCommands; ++i) {
      commands[i] = "";
    }

    // Home first; on success, issue a ping as an important message
    if (homeStepperMotorsPositions()) {
      msgForSerial = "P(" + String(millis()) + ")";  // will be sent by sendImportantData()
      DBG("RESET", "maxReq<=" + maxPayloadToRequest + " homed OK; ping queued");
      return true;
    } else {
      DBG("RESET", "home failed");
      return false;
    }
  }

  if (task == 'U') {
    if (taskInfo.length() != 0) {
      msgForSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    stepMotorsActivated(false);
    return true;
  }

  // Unknown command fallback
  msgForSerial = "EUnknown command: " + String(task);
  digitalWrite(errorLight, HIGH);
  return false;
}

// Able to execute next command in a string of commands
String getNextSection(String input) {
  // Skip 5-char payload ID
  input = input.substring(5);

  int sectionIndex = 0;
  int start = 0;

  while (true) {
    int end = input.indexOf(';', start);

    if (sectionIndex == currentCommandExecution) {
      // If there's a ';', return [start, end)
      if (end != -1) return input.substring(start, end);
      // No more ';' — if there's remaining text, treat it as the last command
      if (start < input.length()) return input.substring(start);
      // Nothing left
      return "";
    }

    // Not our section yet; advance
    if (end == -1) return "";  // ran out of sections
    sectionIndex++;
    start = end + 1;
  }
}

// Send and execute next command or request next payload if needed
void runCommands() {
  if (scriptErrorPaused || scriptWait) return;

  // If we have a selected slot with a payload, try to execute next command
  if (currentCommandStringExecution >= 0 && currentCommandStringExecution < numCommands && commands[currentCommandStringExecution].length() >= 5) {

    String input = commands[currentCommandStringExecution];
    String nextCommand = getNextSection(input);
    DBG("EXEC-PAYLOAD", "raw='" + input + "'");
    DBG("EXEC-TOKEN", "section#" + String(currentCommandExecution) + "='" + nextCommand + "'");


    if (nextCommand != "") {
      DBG("EXEC", "id=" + decimalToBase62((unsigned long)currentCommandNumber, 5) + " slot=" + String(currentCommandStringExecution) + " cmd#" + String(currentCommandExecution) + " -> '" + nextCommand + "'");

      if (executeCommand(nextCommand)) {
        currentCommandExecution++;
        DBG("EXEC-OK", "id=" + decimalToBase62((unsigned long)currentCommandNumber, 5) + " cmd#" + String(currentCommandExecution - 1));
      } else {
        // Unconditionally enter error/pause mode on any command failure
        String reason = lastErrorReason.length() ? lastErrorReason : "executeCommand returned false";
        String out = msgForSerial;  // keep whatever the command set
        enterScriptError(reason, out);
        DBG("EXEC-FAIL", "id=" + decimalToBase62((unsigned long)currentCommandNumber, 5) + " cmd#" + String(currentCommandExecution) + " reason='" + lastErrorReason + "' out='" + msgForSerial + "'");
      }

      return;  // next loop iteration will continue from the updated indices
    }

    // Payload finished: clear & move to the next payload number
    commands[currentCommandStringExecution] = "";
    currentCommandNumber += 1;
    currentCommandExecution = 0;

    unsigned long maxN = b62u(maxPayloadToRequest);
    if (maxN != 0xFFFFFFFFUL) {
      unsigned long justFinished = (unsigned long)(currentCommandNumber - 1);
      // Gcode Finished
      if (justFinished == maxN) {
        finishedCurrentGcode = true;
        DBG("GCODE-DONE", "completed last payload id=" + decimalToBase62(justFinished, 5));
      }
    }

    dumpCommandSlots();
    // fall-through to selection/request for the new currentCommandNumber
  }

  // Select the slot that holds the current payload, if any
  String needId = decimalToBase62((unsigned long)currentCommandNumber, 5);
  int slot = -1;
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == needId) {
      slot = i;
      break;
    }
  }
  if (slot >= 0) {
    if (currentCommandStringExecution != slot) {
      currentCommandStringExecution = slot;
      DBG("PAYLOAD-SELECT", "slot=" + String(slot) + " id=" + needId + " (selected)");
    }
    return;  // we’ll execute it on the next loop iteration
  }

  // Request next payload
  requestNextIfPolicy();
}

// Send bulk data
void sendBulkData() {
  if (millis() > lastDataSend + 2800 && millis() > LastImportantMsg + ImportantMsgDelay) {
    // Packet format (after 5-char unique id and 'D'):
    //  1: flags (scriptErrorPaused, scriptWait, finishedCurrentGcode, Motor enabled, Fan enabled) [base62, 1 char]
    //  2: X Lever                (0/1)
    //  3: X StepPosition         (base62, width 3)
    //  4: X StepTotal            (base62, width 4)
    //  5: Z Lever                (0/1)
    //  6: Z StepPosition         (base62, width 3)
    //  7: Z StepTotal            (base62, width 4)
    //  8: RMagneticEncoderNumber (decimal)
    //  9: RStepRotation          (decimal; using currentRotationOfHead)
    // 10: RStepTotal             (base62, width 4)
    // 11: Motor Uptime           (base62, width 3)
    // 12: Motor Downtime         (base62, width 3)
    // 13: mostRecentConfirmedExecutedCommand (7 chars: 5+2 base62)

        unsigned long now = millis();
    unsigned long dt  = now - LastMotorRunUpdate;         // how long since we last accounted
    if (dt > 0) {
      bool motorsOn = (digitalRead(ENABLE_PIN_MOTOR) == HIGH);
      if (motorsOn) {
        MotorUpTime   += dt;                               // add to uptime
      } else {
        MotorDownTime += dt;                               // add to downtime
      }
      LastMotorRunUpdate = now;                            // reset the cursor
    }

    // Sample A1 for R magnetic encoder
    lastReadMagneticEncoder = readRMagneticEncoder();

    lastMessageSentUniqueID += 1;

    // Flags packed into 1 base62 digit
    char packedFlags = packBooleansToBase62(
      scriptErrorPaused,
      scriptWait,
      finishedCurrentGcode,
      digitalRead(ENABLE_PIN_MOTOR),
      digitalRead(ENABLE_PIN_FAN));

    // base-62 telemetry
    String xPos62 = decimalToBase62((unsigned long)motorStepPositionX, 3);
    String xTot62 = decimalToBase62((unsigned long)motorStepCompleationX, 4);
    String zPos62 = decimalToBase62((unsigned long)motorStepPositionZ, 3);
    String zTot62 = decimalToBase62((unsigned long)motorStepCompleationZ, 4);
    String rTot62 = decimalToBase62((unsigned long)motorStepCompleationR, 4);

    // Last executed pointer (7 chars: 5 + 2 base62)
    String lastExec =
      String(decimalToBase62((unsigned long)currentCommandNumber, 5)) + String(decimalToBase62((unsigned long)currentCommandExecution, 2));

    // Uptime/downtime → deciseconds → base62 width 3 (clamped to 62^3-1)
    const unsigned long B62_3_MAX = 62UL * 62UL * 62UL - 1UL;  // 238,327
    unsigned long up_ds = (MotorUpTime / 100UL);
    if (up_ds > B62_3_MAX) up_ds = B62_3_MAX;
    unsigned long down_ds = (MotorDownTime / 100UL);
    if (down_ds > B62_3_MAX) down_ds = B62_3_MAX;
    String up62 = decimalToBase62(up_ds, 3);
    String down62 = decimalToBase62(down_ds, 3);

    // Assemble payload
    String payload =
      String(decimalToBase62((unsigned long)lastMessageSentUniqueID, 5)) + "D" + String(packedFlags) + ";" +  // 1
      String((int)digitalRead(PressureLever_ReadX)) + ";" +                                                   // 2
      xPos62 + ";" +                                                                                          // 3
      xTot62 + ";" +                                                                                          // 4
      String((int)digitalRead(PressureLever_ReadZ)) + ";" +                                                   // 5
      zPos62 + ";" +                                                                                          // 6
      zTot62 + ";" +                                                                                          // 7
      String(lastReadMagneticEncoder) + ";" +                                                                 // 8
      String(currentRotationOfHead) + ";" +                                                                   // 9
      rTot62 + ";" +                                                                                          // 10
      up62 + ";" +                                                                                            // 12
      down62 + ";" +                                                                                          // 13
      lastExec;                                                                                               // 12

    Serial1.println(payload);

    lastDataSend = millis();
  }
}

// Send priority message
bool sendImportantData() {
  if (msgForSerial != "") {

    lastMessageSentUniqueID += 1;
    String txId62 = decimalToBase62((unsigned long)lastMessageSentUniqueID, 5);

    String wireLine =
      txId62 + "I" + msgForSerial + ";" + String(decimalToBase62((unsigned long)currentCommandStringExecution, 5)) + String(decimalToBase62((unsigned long)currentCommandExecution, 2));

    // Log the actual transmit ID + the body (body has no counters)
    DBG("TXI", txId62 + " " + msgForSerial);

    Serial1.println(wireLine);

    msgForSerial = "";
    lastDataSend = millis();
    LastImportantMsg = millis();
    return true;
  }
  return false;
}

// Check outgoing and inbound messages
void checkCommunication() {
  // — 1) Read & respond to anything incoming (drain quickly)
  while (Serial1.available()) {
    String in = Serial1.readStringUntil('\n');
    in.trim();
    DBG("RX", in);

    if (in.length() == 0) {
      break;  // ignore empty lines
    }

    if (in.startsWith("I")) {
      g_isImmediateExec = true;
      bool ok = executeCommand(in.substring(1));
      g_isImmediateExec = false;
      if (!ok) {
        enterScriptError(lastErrorReason.length() ? lastErrorReason : "Immediate exec failed");
      }

    } else if (in.startsWith("S")) {
      // Drop leading 'S'
      String body = in.substring(1);
      body.trim();

      // Must be at least 6 chars: 5-char ID + at least 1 command char (or ';')
      if (body.length() < 6) {
        msgForSerial = "EStore-short";
        DBG("STORE-ERR", "too short: '" + body + "'");
        return;
      }

      // First 5 chars must be base62 id
      if (!looksBase62Id(body, 0)) {
        msgForSerial = "EStore-badid";
        DBG("STORE-ERR", "bad id in '" + body + "'");
        return;
      }

      String p62 = body.substring(0, 5);
      DBG("STORE", "id=" + p62 + " len=" + String(body.length()));

      // Choose existing slot (same id) or first free
      int slot = -1;
      for (int i = 0; i < numCommands; i++) {
        if (commands[i].length() >= 5 && commands[i].substring(0, 5) == p62) {
          slot = i;
          break;
        }
        if (slot == -1 && commands[i].length() == 0) slot = i;
      }

      if (slot == -1) {
        msgForSerial = "ECommand storage full";
        DBG("STORE-ERR", "no free slot for id=" + p62);
        return;
      }

      commands[slot] = body;  // ← stored WITHOUT 'S'
      DBG("STORE-OK", "slot=" + String(slot) + " id=" + p62);

      // If this is exactly the payload we need next, select it
      if ((int)base62ToDecimal(p62) == currentCommandNumber) {
        currentCommandStringExecution = slot;
        currentCommandExecution = 0;
        DBG("STORE-SELECT", "id=" + p62 + " is current need; selecting slot " + String(slot));
      }

      dumpCommandSlots();
    }
  }

  // Attempt Important data send, if none, attempt bulk data
  if (!sendImportantData()) {
    sendBulkData();
  }
}

// Set up script
void setup() {

  // =============================
  // Set control X pins as outputs
  pinMode(IN1X, OUTPUT);
  pinMode(IN2X, OUTPUT);
  pinMode(IN3X, OUTPUT);
  pinMode(IN4X, OUTPUT);
  pinMode(PressureLever_ReadX, INPUT);

  // ==============================
  // Set control Y pins as outputs
  pinMode(IN1Y, OUTPUT);
  pinMode(IN2Y, OUTPUT);
  pinMode(IN3Y, OUTPUT);
  pinMode(IN4Y, OUTPUT);
  pinMode(PressureLever_ReadY, INPUT);

  // ==============================
  // Set control Z pins as outputs
  pinMode(IN1Z, OUTPUT);
  pinMode(IN2Z, OUTPUT);
  pinMode(IN3Z, OUTPUT);
  pinMode(IN4Z, OUTPUT);
  pinMode(PressureLever_ReadZ, INPUT);

  // ==============================
  // Set control R pins as outputs
  pinMode(IN1R, OUTPUT);
  pinMode(IN2R, OUTPUT);
  pinMode(IN3R, OUTPUT);
  pinMode(IN4R, OUTPUT);

  // ==============================

  pinMode(ENABLE_PIN_MOTOR, OUTPUT);
  pinMode(ENABLE_PIN_FAN, OUTPUT);

  // Initialize Serial1 (TX1/RX1)
  Serial1.begin(9600);
  Serial.begin(DEBUG_SERIAL_BAUD);

  // Debug
  DBG("BOOT", "starting up");

  // Set light pins as outputs
  pinMode(goodLight, OUTPUT);
  pinMode(commLight, OUTPUT);
  pinMode(errorLight, OUTPUT);

  // Until comm connected error light is on
  digitalWrite(commLight, LOW);
}

// Main ongoing script loop
void loop() {

  // process incoming packets & queued bulk updates
  checkCommunication();

  // Run commands if possible
  if (!scriptErrorPaused && !scriptWait && !finishedCurrentGcode) {
    runCommands();
  }
}
