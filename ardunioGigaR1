#include <Arduino.h>
#include <RPC.h>

// ==============================

// Ardunio Info

// ==============================

// Communication
unsigned long lastPingTime = 0;
const unsigned long Imporntant_Ping_Delay = 3000;
unsigned long Last_Imporntant_Ping_Delay = 0;

// Is script error paused
bool scriptErrorPaused = false;
String lastErrorReason = "";

// Is script delayed and waiting for input
bool scriptWait = false;

bool heatSinkFansRunning = false;
unsigned long lastFanChange = 0;

// Last sending out of data in miliseconds
unsigned long lastDataSend = 0;

// Last Receive data in miliseconds
unsigned long lastDataReceive = 0;

// Min/Max step delay
const float minStepDelay = 2.5;
const int maxStepDelay = 8;

// Direct color indicators pins
const int goodLight = 51;
const int commLight = 52;
const int errorLight = 53;

// Motor steps per inch
const int ardunioMotorStepsPerInch = 127;

// Motor enable pin
const int ENABLE_PIN_MOTOR = 22;

// gun motor enable pin
const int ENABLE_PIN_GUNMOTOR = 23;

// Fan enable pin
const int ENABLE_PIN_FAN = 47;

// Target rotation for head
volatile int targetHeadAngleDeg = 0;

// Current known rotation of head
int currentRotationOfHead = 0;

// ==============================

// X H-bridge pins
const int IN1X = 25;
const int IN2X = 27;
const int IN3X = 29;
const int IN4X = 31;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadX = 35;

// X step delay live in milliseconds
int stepDelayX = 5;

// X last step recorded
int lastStepX = 0;

// X max step distance 36 inch
const int maxXStep = 4572;

// X Posiotion from 0
volatile int motorStepPositionX = 0;
volatile int motorStepCompleationX = 0;

volatile int motorUptimeX = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeX = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecX = 0;   // Store last time check

// ==============================

// Y H-bridge pins
const int IN1Y = 39;
const int IN2Y = 41;
const int IN3Y = 43;
const int IN4Y = 45;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadY = 37;

// Y step delay live in milliseconds
int stepDelayY = 5;

// Y last step recorded
int lastStepY = 0;

// Y max step distance 36 inch
const int maxYStep = 4572;

// Y Posiotion from 0
volatile int motorStepPositionY = 0;
volatile int motorStepCompleationY = 0;

volatile int motorUptimeY = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeY = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecY = 0;   // Store last time check

// ==============================

// Z H-bridge pins
const int IN1Z = 24;
const int IN2Z = 26;
const int IN3Z = 28;
const int IN4Z = 30;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadZ = 34;

// Z step delay live in milliseconds
int stepDelayZ = 5;

// Z last step recorded
int lastStepZ = 0;

// Z max step distance 36 inch
const int maxZStep = 4572;

// Z Posiotion from 0
volatile int motorStepPositionZ = 0;
volatile int motorStepCompleationZ = 0;

volatile int motorUptimeZ = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeZ = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecZ = 0;   // Store last time check

// ==============================
// R H-bridge pins
const int IN1R = 38;
const int IN2R = 40;
const int IN3R = 42;
const int IN4R = 44;

// R step delay live in milliseconds
int stepDelayR = 5;

// R last step recorded
int lastStepR = 0;

// R Posiotion from 0
volatile int motorStepPositionR = 0;
int lastReadMagneticEncoder = 0;
volatile int motorStepCompleationR = 0;

volatile int motorUptimeR = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeR = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecR = 0;   // Store last time check

const int R_MAGNETIC_PIN = A1;
// ==============================

// Stepper motor sequence for 4-step drive
const int steps[4][4] = {
  { 1, 0, 1, 0 },  // Step 1
  { 0, 1, 1, 0 },  // Step 2
  { 0, 1, 0, 1 },  // Step 3
  { 1, 0, 0, 1 }   // Step 4
};

// ==============================

// Data to run immediately
String commandNow = "";

unsigned long lastPayloadRequestTime = 0;
String lastPayloadRequested = "";  // avoid duplicate requests


// Set aside room for payloads
const int numCommands = 20;
String commands[numCommands];


// Compleated Executing Info
int currentCommandNumber = 1;
int currentCommandStringExecution = 0;
int currentCommandExecution = 0;

// String to send out to cloud
String msgForAttemptSendOverSerial = "";
int lastMessageSentUniqueID = 0;

// ==============================

// Read Analong 1 magnetic encoder
long readRMagneticEncoder(uint8_t samples = 8) {
  long acc = 0;
  for (uint8_t i = 0; i < samples; ++i) {
    acc += analogRead(R_MAGNETIC_PIN);
  }
  return acc / samples;
}

String decimalToBase36(unsigned long number, int minLength = 5) {
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  String result = "";

  if (number == 0) result = "0";
  else {
    while (number > 0) {
      result = chars[number % 36] + result;
      number /= 36;
    }
  }

  // Pad to desired length
  while (result.length() < minLength) {
    result = "0" + result;
  }

  return result;
}

// Decode base 36 to decimal
unsigned long base36ToDecimal(String input) {
  input.toLowerCase();
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  unsigned long result = 0;

  for (int i = 0; i < input.length(); ++i) {
    char c = input.charAt(i);
    const char* pos = strchr(chars, c);

    if (pos == nullptr) {
      // Invalid character; handle it how you want (return 0, error code, etc.)
      return 0;
    }

    int value = pos - chars;
    result = result * 36 + value;
  }

  return result;
}

// ==============================
// Debug helpers
// ==============================
#ifndef DEBUG_SERIAL_BAUD
#define DEBUG_SERIAL_BAUD 115200
#endif
#define TXDBG(msg) \
  Serial.print("[TX] "); \
  Serial.println(msg)

// prefix logs with millis and a short tag
void DBG(const String& tag, const String& msg) {
  Serial.print('[');
  Serial.print(millis());
  Serial.print("] ");
  Serial.print(tag);
  Serial.print(": ");
  Serial.println(msg);
}

String payloadIdAt(int idx) {
  if (idx < 0) return "-----";
  if (idx >= 12) return "-----";
  if (commands[idx].length() >= 5) return commands[idx].substring(0, 5);
  return "-----";
}

// Quick snapshot of slot occupancy and pointers
void dumpCommandSlots() {
  Serial.println(F("---- SLOTS ----"));
  for (int i = 0; i < numCommands; i++) {
    String id = (commands[i].length() >= 5) ? commands[i].substring(0, 5) : "-----";
    Serial.print(i);
    Serial.print(": ");
    Serial.print(id);
    if (i == currentCommandStringExecution) Serial.print("  <CUR>");
    Serial.println();
  }
  Serial.print(F("currentCommandNumber="));
  Serial.println(currentCommandNumber);
  Serial.print(F("currentCommandExecution="));
  Serial.println(currentCommandExecution);
  Serial.println(F("----------------"));
}

String base36_5(unsigned long v) {
  return decimalToBase36(v, 5);
}
String base36_2(unsigned long v) {
  return decimalToBase36(v, 2);
}

// Function to energize X stepper motor coils
bool stepMotorX(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  // Normalize target step to 0..3
  step = (step % 4 + 4) % 4;

  // Direction from last energized phase: +1 (forward), +3 (backward), 0 (hold), 2 (invalid skip)
  int direction = (step - lastStepX + 4) % 4;

  // Decide motion & bounds
  bool moved = false;
  if (direction == 1) {  // forward
    if (ignoreBounds || motorStepPositionX < maxXStep) {
      motorStepPositionX++;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OOB fwd pos=" + String(motorStepPositionX) + " max=" + String(maxXStep);
      lastErrorReason = "Step Motor X ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 3) {  // backward
    if (ignoreBounds || motorStepPositionX > 0) {
      motorStepPositionX--;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OOB back pos=" + String(motorStepPositionX);
      lastErrorReason = "Step Motor X ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 2) {
    // Skipping one phase is an electrical mismatch—reject it
    msgForAttemptSendOverSerial = "EMotor X invalid phase jump";
    lastErrorReason = "Invalid X phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return false;
  }
  // direction==0 means "re-energize same phase" → no movement, allowed

  // Energize coils
  digitalWrite(IN1X, steps[step][0]);
  digitalWrite(IN2X, steps[step][1]);
  digitalWrite(IN3X, steps[step][2]);
  digitalWrite(IN4X, steps[step][3]);

  // Update last phase and step counters
  lastStepX = step;
  if (moved) motorStepCompleationX++;

  return true;
}

bool stepMotorXForward(bool ignoreBounds) {
  int nextStep = (lastStepX + 1) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

bool stepMotorXBackward(bool ignoreBounds) {
  int nextStep = (lastStepX + 3) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Function to energize Z stepper motor coils
bool stepMotorZ(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  // Normalize target step to 0..3
  step = (step % 4 + 4) % 4;

  // Direction from last energized phase
  int direction = (step - lastStepZ + 4) % 4;

  bool moved = false;
  if (direction == 1) {  // forward
    if (ignoreBounds || motorStepPositionZ < maxZStep) {
      motorStepPositionZ++;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OOB fwd pos=" + String(motorStepPositionZ) + " max=" + String(maxZStep);
      lastErrorReason = "Step Motor Z ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 3) {  // backward
    if (ignoreBounds || motorStepPositionZ > 0) {
      motorStepPositionZ--;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OOB back pos=" + String(motorStepPositionZ);
      lastErrorReason = "Step Motor Z ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 2) {
    msgForAttemptSendOverSerial = "EMotor Z invalid phase jump";
    lastErrorReason = "Invalid Z phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return false;
  }
  // direction==0: hold phase

  // Energize coils
  digitalWrite(IN1Z, steps[step][0]);
  digitalWrite(IN2Z, steps[step][1]);
  digitalWrite(IN3Z, steps[step][2]);
  digitalWrite(IN4Z, steps[step][3]);

  // Update last phase and counters
  lastStepZ = step;
  if (moved) motorStepCompleationZ++;

  return true;
}

bool stepMotorZForward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 1) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

bool stepMotorZBackward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 3) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Hold Motors
void stepMotorsActivated(bool run) {

  unsigned long currentMillis = millis();  // Get the current time

  // Update uptime or downtime based on the motor state
  if (run) {
    digitalWrite(ENABLE_PIN_MOTOR, HIGH);
    digitalWrite(ENABLE_PIN_FAN, HIGH);
    motorUptimeX += currentMillis - lastMilisecX;  // Increment uptime
  } else {
    digitalWrite(ENABLE_PIN_MOTOR, LOW);
    digitalWrite(ENABLE_PIN_FAN, LOW);
    motorDowntimeX += currentMillis - lastMilisecX;  // Increment downtime
  }

  // Update lastMillis to the current time
  lastMilisecX = currentMillis;
}

// two-digit "ms" field: "XY" -> X.Y milliseconds (0.0..9.9)
static inline float parseTwoDigitMs(const String& s, int off = 0) {
  int d0 = s.charAt(off) - '0';
  int d1 = s.charAt(off + 1) - '0';
  if (d0 < 0 || d0 > 9 || d1 < 0 || d1 > 9) return 0.0f;
  return d0 + d1 * 0.1f;
}

// sign-pair '0'..'3' => (+/+),(-/+),(+/-),(-/-)
static inline void applySignPair(char sp, int& xs, int& zs) {
  switch (sp) {
    case '0': /* +/+ */ break;
    case '1': xs = -xs; break;  // (-/+)
    case '2': zs = -zs; break;  // (+/-)
    case '3':
      xs = -xs;
      zs = -zs;  // (-/-)
      break;
    default: /* invalid handled in caller */ break;
  }
}

// ---- BUFFER / LOOKUP HELPERS ----

// Return slot index [0..numCommands-1] that holds the payload id36, or -1 if absent
int findSlotById36(const String& id36) {
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == id36) return i;
  }
  return -1;
}

// Count empty slots across ALL 20
int countEmptySlotsAll() {
  int c = 0;
  for (int i = 0; i < numCommands; i++)
    if (commands[i].length() == 0) c++;
  return c;
}

// Queue a specific "R<id36>" request (rate-limited)
bool requestSpecificIfDue(const String& id36) {
  if (millis() - lastPayloadRequestTime <= Imporntant_Ping_Delay) return false;
  String constructed = "R" + id36;
  // optional: suppress exact duplicates back-to-back
  if (constructed == lastPayloadRequested && msgForAttemptSendOverSerial != "") return false;

  msgForAttemptSendOverSerial = constructed;
  lastPayloadRequested = constructed;
  lastPayloadRequestTime = millis();
  DBG("REQ", "specific id=" + id36);
  return true;
}

// Queue an "RMORE" (rate-limited) when buffer is low
bool requestMoreIfDue() {
  if (millis() - lastPayloadRequestTime <= Imporntant_Ping_Delay) return false;
  if (msgForAttemptSendOverSerial != "") return false;  // don't clobber a specific request

  msgForAttemptSendOverSerial = "RMORE";
  lastPayloadRequestTime = millis();
  DBG("REQ", "buffer low -> RMORE");
  return true;
}

// Ensure we’re executing the slot that holds currentCommandNumber (if present)
bool selectCurrentIfPresent() {
  String needId = decimalToBase36((unsigned long)currentCommandNumber, 5);
  int slot = findSlotById36(needId);
  if (slot >= 0) {
    if (currentCommandStringExecution != slot) {
      currentCommandStringExecution = slot;
      DBG("PAYLOAD-SELECT", "slot=" + String(slot) + " id=" + needId + " (selected)");
    }
    return true;
  }
  return false;
}


// --- HOMING HELPERS ---

// Generic homing routine for one axis.
// - Approaches the limit switch in the "forward" direction
// - On trigger: sets position=0, then backs off ~1 inch (reverse) to clear the lever
// - Uses your existing step functions and timing
static bool homeOneAxis(
  const char* axisName,
  int leverPin,
  int maxStep,
  int stepsPerInch,
  int stepDelayMs,
  bool (*stepForward)(bool),
  bool (*stepBackward)(bool),
  volatile int& stepPositionVar,
  volatile int& stepCompletionVar) {
  // Ensure motors are powered while homing
  stepMotorsActivated(true);

  // Approach the switch (ignore bounds while seeking home)
  for (int i = 0; i < maxStep; ++i) {
    if (!stepForward(true)) {
      msgForAttemptSendOverSerial = String("EHome ") + axisName + " step fwd fail";
      lastErrorReason = String("Home ") + axisName + " step forward failed";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
    delay(stepDelayMs);

    if (digitalRead(leverPin) == HIGH) {
      // Hit the lever ⇒ define this as zero
      stepPositionVar = 0;

      // Back off ~1 inch to clear the switch
      for (int j = 0; j < stepsPerInch; ++j) {
        if (!stepBackward(true)) {
          msgForAttemptSendOverSerial = String("EHome ") + axisName + " backoff fail";
          lastErrorReason = String("Home ") + axisName + " backoff failed";
          scriptErrorPaused = true;
          digitalWrite(errorLight, HIGH);
          return false;
        }
        delay(stepDelayMs);
        // If the lever is cleared early, keep backing off to the full inch (consistent behavior)
      }

      // Confirm lever cleared
      if (digitalRead(leverPin) == HIGH) {
        msgForAttemptSendOverSerial = String("EHome ") + axisName + " lever stuck";
        lastErrorReason = String("Home ") + axisName + " lever still HIGH after backoff";
        scriptErrorPaused = true;
        digitalWrite(errorLight, HIGH);
        return false;
      }
      return true;
    }
  }

  // Never triggered within travel
  msgForAttemptSendOverSerial = String("EFailed to home ") + axisName;
  lastErrorReason = String("Home ") + axisName + " never triggered lever";
  scriptErrorPaused = true;
  digitalWrite(errorLight, HIGH);
  return false;
}

// Homes Stepper Motors; returns true only if all succeed.
bool homeStepperMotorsPositions() {
  // Use your existing per-axis delays
  int useDelayX = stepDelayX > 0 ? stepDelayX : 5;
  int useDelayZ = stepDelayZ > 0 ? stepDelayZ : 5;

  bool okX = homeOneAxis(
    "X",
    PressureLever_ReadX,
    maxXStep,
    ardunioMotorStepsPerInch,
    useDelayX,
    &stepMotorXForward,
    &stepMotorXBackward,
    motorStepPositionX,
    motorStepCompleationX);

  if (!okX) return false;

  bool okZ = homeOneAxis(
    "Z",
    PressureLever_ReadZ,
    maxZStep,
    ardunioMotorStepsPerInch,
    useDelayZ,
    &stepMotorZForward,
    &stepMotorZBackward,
    motorStepPositionZ,
    motorStepCompleationZ);

  return okZ;
}

// Execute individual command
bool executeCommand(String givenString) {
  // Task of command
  char task = givenString[0];

  // Info for task to be executed, if any
  String taskInfo = givenString.substring(1);

  DBG("EXEC-IN", "task=" + String(givenString[0]) + " info='" + taskInfo + "'" + " id=" + base36_5((unsigned long)currentCommandNumber) + " cmd#" + String(currentCommandExecution));


  // Pause script due to error
  if (task == 'A') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);

    scriptErrorPaused = true;
    lastErrorReason = "Forced Into Error state by command";
    digitalWrite(errorLight, HIGH);
    return true;
  }

  // Unpause script due to error
  if (task == 'B') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);

    scriptErrorPaused = false;
    digitalWrite(errorLight, LOW);
    return true;
  }

  // Put script into wait mode
  if (task == 'C') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = true;
    return true;
  }

  // Remove script from wait mode
  if (task == 'D') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = false;
    return true;
  }

  // Step motor X forward
  if (task == 'E') return stepMotorXForward(false);
  // Step motor X backward
  if (task == 'F') return stepMotorXBackward(false);
  // Step motor Z forward
  if (task == 'G') return stepMotorZForward(false);
  // Step motor Z backward
  if (task == 'H') return stepMotorZBackward(false);

  // Step motor X by relative step count
  if (task == 'I') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorXForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorXBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Step motor Z by relative step count
  if (task == 'J') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorZForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorZBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Hold all motor positions with force
  if (task == 'K') {
    if (taskInfo.length() != 0) {
      msgForAttemptSendOverSerial = "EK-length " + String(taskInfo);
      return false;
    }
    stepMotorsActivated(true);
    return true;
  }

  // Move motor X to specific step (LddXXXX where dd=ms, XXXX=base36 width 4)
  if (task == 'L') {
    if (taskInfo.length() != 6) {
      msgForAttemptSendOverSerial = "EL-length " + String(taskInfo);
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base36ToDecimal(taskInfo.substring(2, 6));  // 4 chars, 0..1,679,615
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxXStep) {
      while (motorStepPositionX != StepPosition) {
        if (motorStepPositionX < StepPosition) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        delay(tempdelay);
      }
      return true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OOB (" + String(StepPosition) + ") max (" + String(maxXStep) + ")";
      return false;
    }
  }

  // Move motor Z to specific step (MddXXXX where dd=ms, XXXX=base36 width 4)
  if (task == 'M') {
    if (taskInfo.length() != 6) {
      msgForAttemptSendOverSerial = "EM-length " + String(taskInfo);
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base36ToDecimal(taskInfo.substring(2, 6));
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxZStep) {
      while (motorStepPositionZ != StepPosition) {
        if (motorStepPositionZ < StepPosition) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        delay(tempdelay);
      }
      return true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OOB (" + String(StepPosition) + ") max (" + String(maxZStep) + ")";
      return false;
    }
  }

  // Ping back to server
  if (task == 'N') {
    if (taskInfo.length() != 0) {
      msgForAttemptSendOverSerial = "EN-length " + String(taskInfo);
      return false;
    }
    msgForAttemptSendOverSerial = "P(" + String(millis()) + ")";
    return true;
  }


  // O + [delay(2)] + [signPair(1)] + [x36(3)] + [z36(3)]  => taskInfo.len == 9
if (task == 'O') {
  if (taskInfo.length() != 9) {
    msgForAttemptSendOverSerial = "EO-length " + String(taskInfo);
    digitalWrite(errorLight, HIGH);
    return false;
  }

  // Parse fields (delay + sign + magnitudes)
  float baseDelay = parseTwoDigitMs(taskInfo, 0);  // 0.0..9.9 ms
  char signPair = taskInfo.charAt(2);
  if (signPair < '0' || signPair > '3') {
    msgForAttemptSendOverSerial = "EO-sign";
    digitalWrite(errorLight, HIGH);
    return false;
  }

  unsigned long xMagUL = base36ToDecimal(taskInfo.substring(3, 6));  // 3 chars
  unsigned long zMagUL = base36ToDecimal(taskInfo.substring(6, 9));  // 3 chars
  if (xMagUL > 46655UL || zMagUL > 46655UL) {                        // 36^3 - 1
    msgForAttemptSendOverSerial = "EO-mag36";
    digitalWrite(errorLight, HIGH);
    return false;
  }

 // Convert base36 magnitudes to absolute target positions (in steps)
long targetX = (long)xMagUL;
long targetZ = (long)zMagUL;

// Compute relative deltas from current position
long xSteps = targetX - (long)motorStepPositionX;
long zSteps = targetZ - (long)motorStepPositionZ;

DBG("O-ABS", "curX=" + String(motorStepPositionX) +
             " tgtX=" + String(targetX) +
             " dx="   + String(xSteps) +
             " curZ=" + String(motorStepPositionZ) +
             " tgtZ=" + String(targetZ) +
             " dz="   + String(zSteps));


// Apply sign pair if you still want to support the old relative encoding,
// but if you’re always sending absolute values now, you can comment this out.
// applySignPair(signPair, xSteps, zSteps);

// ---- Bounds safety ----
long projX = motorStepPositionX + xSteps;
long projZ = motorStepPositionZ + zSteps;

if (projX < 0 || projX > maxXStep || projZ < 0 || projZ > maxZStep) {
  msgForAttemptSendOverSerial =
    "EO-OOB x:" + String(motorStepPositionX) + "->" + String(projX) +
    " z:" + String(motorStepPositionZ) + "->" + String(projZ);
  lastErrorReason = "O move out of bounds";
  scriptErrorPaused = true;
  digitalWrite(errorLight, HIGH);
  return false;
}


  // Compute per-axis step periods so both finish together
  int ax = abs(xSteps), az = abs(zSteps);
  int maxSteps = (ax > az) ? ax : az;

  float xDelay = (ax == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)ax);
  float zDelay = (az == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)az);

  // Parallel stepping (simple millis() scheduler)
  unsigned long nextX = millis();
  unsigned long nextZ = nextX;

  int remX = ax, remZ = az;
  int dirX = (xSteps >= 0) ? +1 : -1;
  int dirZ = (zSteps >= 0) ? +1 : -1;

  while (remX > 0 || remZ > 0) {
    unsigned long now = millis();

    if (remX > 0 && now >= nextX) {
      if (dirX > 0) { if (!stepMotorXForward(false)) return false; }
      else           { if (!stepMotorXBackward(false)) return false; }
      remX--;
      nextX = now + (unsigned long)(xDelay);
    }

    if (remZ > 0 && now >= nextZ) {
      if (dirZ > 0) { if (!stepMotorZForward(false)) return false; }
      else           { if (!stepMotorZBackward(false)) return false; }
      remZ--;
      nextZ = now + (unsigned long)(zDelay);
    }

    delay(1);  // simple pacing
  }

  return true;
}

  // Rotate head
  if (task == 'P') {
    if (taskInfo.length() != 2) {
      msgForAttemptSendOverSerial = "EP-length " + String(taskInfo);
      return false;
    }
    unsigned long angUL = base36ToDecimal(taskInfo);
    int angle = (int)(angUL % 360UL);
    targetHeadAngleDeg = angle;

    return true;
  }

  // Home motors
  if (task == 'Q') {
    if (taskInfo.length() != 0) {
      msgForAttemptSendOverSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    return homeStepperMotorsPositions();
  }

    // Tool up
  if (task == 'R') {
    if (taskInfo.length() != 0) {
      msgForAttemptSendOverSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    return true;
  }

    // Tool down
  if (task == 'S') {
    if (taskInfo.length() != 0) {
      msgForAttemptSendOverSerial = "EQ-length " + String(taskInfo);
      return false;
    }
    return true;
  }

  // Unknown command fallback
  msgForAttemptSendOverSerial = "EUnknown command: " + String(task);
  digitalWrite(errorLight, HIGH);
  return false;
}

// Able to execute next command in a string of commands
String getNextSection(String input) {
  // Skip 5-char payload ID
  input = input.substring(5);

  int sectionIndex = 0;
  int start = 0;

  while (true) {
    int end = input.indexOf(';', start);

    if (sectionIndex == currentCommandExecution) {
      // If there's a ';', return [start, end)
      if (end != -1) return input.substring(start, end);
      // No more ';' — if there's remaining text, treat it as the last command
      if (start < input.length()) return input.substring(start);
      // Nothing left
      return "";
    }

    // Not our section yet; advance
    if (end == -1) return "";  // ran out of sections
    sectionIndex++;
    start = end + 1;
  }
}

// Send and execute next command or request next payload if needed
void runCommands() {
  if (scriptErrorPaused || scriptWait) return;

  // If we have a selected slot with a payload, try to execute next command
  if (currentCommandStringExecution >= 0 &&
      currentCommandStringExecution < numCommands &&
      commands[currentCommandStringExecution].length() >= 5) {

    String input = commands[currentCommandStringExecution];
    String nextCommand = getNextSection(input);

    if (nextCommand != "") {
      DBG("EXEC", "id=" + base36_5((unsigned long)currentCommandNumber) +
                  " slot=" + String(currentCommandStringExecution) +
                  " cmd#" + String(currentCommandExecution) +
                  " -> '" + nextCommand + "'");

      if (executeCommand(nextCommand)) {
        // Successful command ⇒ advance within this payload
        currentCommandExecution++;
        DBG("EXEC-OK", "id=" + base36_5((unsigned long)currentCommandNumber) +
                       " cmd#" + String(currentCommandExecution - 1));
      } else {
        // Failure paths already set flags/lights/message
        DBG("EXEC-FAIL", "id=" + base36_5((unsigned long)currentCommandNumber) +
                         " cmd#" + String(currentCommandExecution) +
                         " reason='" + lastErrorReason + "' out='" + msgForAttemptSendOverSerial + "'");
      }
      return; // next loop iteration will continue from the updated indices
    }

    // Payload finished: clear & move to the next payload number
    DBG("PAYLOAD-DONE", "slot=" + String(currentCommandStringExecution) +
                        " id=" + payloadIdAt(currentCommandStringExecution));
    commands[currentCommandStringExecution] = "";
    currentCommandNumber += 1;
    currentCommandExecution = 0;

    dumpCommandSlots();
    // fall-through to selection/request for the new currentCommandNumber
  }

  // Select the slot that holds the current payload, if any
  String needId = decimalToBase36((unsigned long)currentCommandNumber, 5);
  int slot = -1;
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == needId) {
      slot = i;
      break;
    }
  }
  if (slot >= 0) {
    if (currentCommandStringExecution != slot) {
      currentCommandStringExecution = slot;
      DBG("PAYLOAD-SELECT", "slot=" + String(slot) + " id=" + needId + " (selected)");
    }
    return; // we’ll execute it on the next loop iteration
  }

  // Current payload not present ⇒ request ONLY the next needed one
// Current payload not present ⇒ request ONLY the next needed one
if (msgForAttemptSendOverSerial == "") {
  if (millis() - lastPayloadRequestTime > Imporntant_Ping_Delay) {
    String needId = decimalToBase36((unsigned long)currentCommandNumber, 5);
    String constructed = "R" + needId;          // <-- body is just R<id36>
    lastPayloadRequested = constructed;          // (optional: remember last)
    msgForAttemptSendOverSerial = constructed;   // queue it
    lastPayloadRequestTime = millis();
    DBG("REQ", "specific id=" + needId);
  }
}

}

// Send bulk data
void sendBulkData() {
  if (millis() > lastDataSend + 3000 && millis() > Last_Imporntant_Ping_Delay + Imporntant_Ping_Delay) {
    // Packet format (after 5-char unique id and 'D'):
    //  1: scriptErrorPaused (0/1)
    //  2: scriptWait        (0/1)
    //  3: X Lever           (0/1)
    //  4: X StepPosition    (base36, width 3)
    //  5: X StepTotal       (base36, width 4)
    //  6: Z Lever           (0/1)
    //  7: Z StepPosition    (base36, width 3)
    //  8: Z StepTotal       (base36, width 4)
    //  9: RMagneticEncoderNumber (decimal)
    // 10: RStepRotation         (decimal; using currentRotationOfHead)
    // 11: RStepTotal            (base36, width 4)
    // 12: Motor enabled      (0/1)
    // 13: Fan enabled        (0/1)
    // 14: mostRecentConfirmedExecutedCommand (7 chars: 5+2 base36, no semicolon inside)

    // Sample A1 for R magnetic encoder
    lastReadMagneticEncoder = readRMagneticEncoder();  // <-- NEW

    lastMessageSentUniqueID += 1;

    // base-36 step telemetry (width 4)
    String xPos36 = decimalToBase36((unsigned long)motorStepPositionX, 3);
    String xTot36 = decimalToBase36((unsigned long)motorStepCompleationX, 4);
    String zPos36 = decimalToBase36((unsigned long)motorStepPositionZ, 3);
    String zTot36 = decimalToBase36((unsigned long)motorStepCompleationZ, 4);
    String rTot36 = decimalToBase36((unsigned long)motorStepCompleationR, 4);

    String lastExec = String(decimalToBase36((unsigned long)currentCommandStringExecution, 5))
                      + String(decimalToBase36((unsigned long)currentCommandExecution, 2));

    // Field order matches your Roblox map (1..14)
    String payload =
      String(decimalToBase36((unsigned long)lastMessageSentUniqueID, 5)) + "D" + String((int)scriptErrorPaused) + ";" +  // 1
      String((int)scriptWait) + ";" +                                                                                    // 2
      String((int)digitalRead(PressureLever_ReadX)) + ";" +                                                              // 3
      xPos36 + ";" +                                                                                                     // 4 (base36)
      xTot36 + ";" +                                                                                                     // 5 (base36)
      String((int)digitalRead(PressureLever_ReadZ)) + ";" +                                                              // 6
      zPos36 + ";" +                                                                                                     // 7 (base36)
      zTot36 + ";" +                                                                                                     // 8 (base36)
      String(lastReadMagneticEncoder) + ";" +                                                                            // 9 (DECIMAL) from A1
      String(currentRotationOfHead) + ";" +                                                                              // 10 (DECIMAL)
      rTot36 + ";" +                                                                                                     // 11 (base36)
      String((int)digitalRead(ENABLE_PIN_MOTOR)) + ";" +                                                                 // 12
      String((int)digitalRead(ENABLE_PIN_FAN)) + ";" +                                                                   // 13
      lastExec;                                                                                                          // 14 (7 chars, no ';')

    Serial1.println(payload);
    TXDBG(payload);

    lastDataSend = millis();
  }
}

// Send priority message
bool sendImporntantData() {
  if (msgForAttemptSendOverSerial != "") {

    lastMessageSentUniqueID += 1;
    String txId36 = decimalToBase36((unsigned long)lastMessageSentUniqueID, 5);

    String wireLine =
      txId36 + "I" + msgForAttemptSendOverSerial + ";" +
      String(decimalToBase36((unsigned long)currentCommandStringExecution, 5)) +
      String(decimalToBase36((unsigned long)currentCommandExecution, 2));

    // Log the actual transmit ID + the body (body has no counters)
    DBG("TXI", txId36 + " " + msgForAttemptSendOverSerial);

    Serial1.println(wireLine);

    msgForAttemptSendOverSerial = "";
    lastDataSend = millis();
    Last_Imporntant_Ping_Delay = millis();
    return true;
  }
  return false;
}


// Check outgoing and inbound messages
void checkCommunication() {
  // — 1) Read & respond to anything incoming (drain quickly)
  while (Serial1.available()) {
    String in = Serial1.readStringUntil('\n');
    in.trim();
    DBG("RX", in);
    if (in.length() == 0) break;  // ignore empty lines
    // continue; do NOT return here—let the common logic run below
    if (in.startsWith("I")) {
      if (!executeCommand(in.substring(1))) {
        scriptErrorPaused = true;
        digitalWrite(errorLight, HIGH);
      }
    } else if (in.startsWith("S")) {
      String body = in.substring(1);

      if (body.length() < 6) {
        msgForAttemptSendOverSerial = "EStore-short";
        DBG("STORE-ERR", "too short: '" + body + "'");
      } else {
        String p36 = body.substring(0, 5);
        unsigned long pNumUL = base36ToDecimal(p36);
        int pNum = (int)pNumUL;

        DBG("STORE", "id=" + p36 + " len=" + String(body.length()));

        int slot = -1;
        for (int i = 0; i < numCommands; i++) {
          if (commands[i].length() >= 5 && commands[i].substring(0, 5) == p36) {
            slot = i;
            break;
          }
          if (slot == -1 && commands[i].length() == 0) slot = i;
        }

        if (slot == -1) {
          msgForAttemptSendOverSerial = "ECommand storage full";
          DBG("STORE-ERR", "no free slot for id=" + p36);
        } else {
          commands[slot] = body;
          DBG("STORE-OK", "slot=" + String(slot) + " id=" + p36);
          if (pNum == currentCommandNumber) {
            currentCommandStringExecution = slot;
            currentCommandExecution = 0;
            DBG("STORE-SELECT", "id=" + p36 + " is current need; selecting slot " + String(slot));
          }
          dumpCommandSlots();
        }
      }
    }
  }

  // send your data
  if (!sendImporntantData()) {
    sendBulkData();
  }
}


// Set up script
void setup() {

  // Set control X pins as outputs
  pinMode(IN1X, OUTPUT);
  pinMode(IN2X, OUTPUT);
  pinMode(IN3X, OUTPUT);
  pinMode(IN4X, OUTPUT);
  pinMode(PressureLever_ReadX, INPUT);

  // ==============================
  // Set control Y pins as outputs
  pinMode(IN1Y, OUTPUT);
  pinMode(IN2Y, OUTPUT);
  pinMode(IN3Y, OUTPUT);
  pinMode(IN4Y, OUTPUT);
  pinMode(PressureLever_ReadY, INPUT);

  // ==============================
  // Set control Z pins as outputs
  pinMode(IN1Z, OUTPUT);
  pinMode(IN2Z, OUTPUT);
  pinMode(IN3Z, OUTPUT);
  pinMode(IN4Z, OUTPUT);
  pinMode(PressureLever_ReadZ, INPUT);

  // ==============================

  // Set control R pins as outputs
  pinMode(IN1R, OUTPUT);
  pinMode(IN2R, OUTPUT);
  pinMode(IN3R, OUTPUT);
  pinMode(IN4R, OUTPUT);

  // ==============================

  pinMode(ENABLE_PIN_MOTOR, OUTPUT);
  pinMode(ENABLE_PIN_FAN, OUTPUT);

  // Initialize Serial1 (TX1/RX1) at 9600 baud for ardunio to ardunio communication
  Serial1.begin(9600);
  //Serial.begin(9600);
  Serial.begin(DEBUG_SERIAL_BAUD);
  DBG("BOOT", "starting up");

  // Set light pins as outputs
  pinMode(goodLight, OUTPUT);
  pinMode(commLight, OUTPUT);
  pinMode(errorLight, OUTPUT);

  // Until comm connected error light is on
  digitalWrite(commLight, LOW);

  // Find and home motor positions
  homeStepperMotorsPositions();
}

// Main ongoing script loop
void loop() {

  // process incoming packets & queued bulk updates
  checkCommunication();

  // Run commands if posible
  if (!scriptErrorPaused && !scriptWait) {
    runCommands();
  }
}
