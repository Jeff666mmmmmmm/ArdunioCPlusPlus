// Insertion of files
// ==============================

// Include arduino functions
#include <Arduino.h>

// Include multiple processor functions
#include <RPC.h>

// Include properties file
#include "thingProperties.h"

// Communication Variables
// ==============================

// Delay between important messages
const unsigned long ImportantMsgDelay = 2500;

// Last Important message out
unsigned long LastImportantMsgSend = millis();

// Last sending out of data in milliseconds
unsigned long lastDataSend = millis();

// Last receive in of data in milliseconds
unsigned long lastDataIn = millis();

// Is script error paused
bool scriptErrorPaused = false;

// Last saved reason for error
String lastErrorReason = "";

// Is script delayed and waiting for input
bool scriptWait = false;

// Data to run immediately
String commandNow = "";

// Last data sent out ID
int lastMessageSentUniqueID = 0;

// Payload And Command Variables
// ==============================

// Last request for payload
unsigned long lastPayloadRequestTime = 0;

// Number of slots storable for payloads
const int numCommands = 25;

// Actual payload storage
String commands[numCommands];

// Current payload executing ID
int currentCommandNumberID = 1;

// Current Slot we are executing code from
int currentCommandExecutionSlot = 0;

// Current command we are executing
int currentCommandExecution = 0;

// current command is to be executed immediately
static bool currentCommandInstantExecution = false;

// Max payload we are requesting
String maxPayloadToRequest = "";

// Are we finished current gcode
bool finishedCurrentGcode = true;

// Function Variables
// ==============================

// Are fans currently running
bool heatSinkFansRunning = false;

// Last fan change update
unsigned long lastFanChange = millis();

// Input Switch
const int inputSwitch = A4;

// Last input switch change update
unsigned long lastSwitchChange = millis();

int lastSwitchRead = false;

// Info notification LED
const int wifiLedPin = 42;

// Communication notification LED
const int commLedPin = 43;

// Running notification LED
const int runLedPin = 44;

// Action notification LED
const int actionLedPin = 45;

// Error notification LED
const int errorLedPin = 46;

// All Motor Variables
// ==============================

// Stepper motor sequence for 4-step drive
const int steps[4][4] = {
  { 1, 0, 1, 0 },  // Step 1
  { 0, 1, 1, 0 },  // Step 2
  { 0, 1, 0, 1 },  // Step 3
  { 1, 0, 0, 1 }   // Step 4
};

// Delay between payload requests
const unsigned long PayloadMsgDelay = 6000;

// Min step delay
const float minStepDelay = 2.5;

// Max step delay
const int maxStepDelay = 8;

// Motor steps per inch
const int arduinoMotorStepsPerInch = 127;

// Motor enable pin
const int ENABLE_PIN_MOTOR = 39;

// Motor Y enable pin
const int ENABLE_PIN_MOTORY = 38;

// Motor uptime in milliseconds
volatile int MotorUpTime = 0;

// Motor downtime in milliseconds
volatile int MotorDownTime = 0;

// Last time update in milliseconds
unsigned long LastMotorRunUpdate = 0;

// gun motor enable pin
const int ENABLE_PIN_GUNMOTOR = 41;

// Fan enable pin
const int ENABLE_PIN_FAN = 40;

// X Motor specific Variables
// ==============================

// H-bridge pin outs
const int IN1X = 23;
const int IN2X = 25;
const int IN3X = 27;
const int IN4X = 29;

// Axis direction configuration
const int X_SIGN = -1;

// Lever input polarity
const bool X_LEVER_ACTIVE_HIGH = true;

// Pressure Lever minimum position
const int PressureLever_ReadX = A0;

// Step delay in milliseconds
int stepDelayX = 3;

// Last step recorded
int lastStepX = 0;

// Max step distance
const int maxXStep = 36 * arduinoMotorStepsPerInch;

// Position from 0
volatile int motorStepPositionX = 0;

// Total Steps Completed
volatile int motorStepCompletionX = 0;

// Y Motor specific Variables
// ==============================

// H-bridge pin outs
const int IN1Y = 22;
const int IN2Y = 24;
const int IN3Y = 26;
const int IN4Y = 28;

// Axis direction configuration
const int Y_SIGN = -1;

// Lever input polarity
const bool Y_LEVER_ACTIVE_HIGH = true;

// Pressure Lever minimum position
const int PressureLever_ReadY = A1;

// Step delay milliseconds
int stepDelayY = 3;

// Last step recorded
int lastStepY = 0;

// Max step distance
const int maxYStep = 36 * arduinoMotorStepsPerInch;

// Position from 0
volatile int motorStepPositionY = 0;

// Total Steps Completed
volatile int motorStepCompletionY = 0;

// Z Motor specific Variables
// ==============================

// H-bridge pins
const int IN1Z = 31;
const int IN2Z = 33;
const int IN3Z = 35;
const int IN4Z = 37;

// Axis direction configuration
const int Z_SIGN = -1;

// Lever input polarity
const bool Z_LEVER_ACTIVE_HIGH = true;

// Pressure Lever minimum position
const int PressureLever_ReadZ = A2;

// Step delay in milliseconds
int stepDelayZ = 3;

// Last step recorded
int lastStepZ = 0;

// Max step distance
const int maxZStep = 36 * arduinoMotorStepsPerInch;

// Position from 0
volatile int motorStepPositionZ = 0;

// Total Steps Completed
volatile int motorStepCompletionZ = 0;

// R Motor specific Variables
// ==============================

// H-bridge pins
const int IN1R = 30;
const int IN2R = 32;
const int IN3R = 34;
const int IN4R = 36;

// Axis direction configuration
const int R_SIGN = -1;

// Magnetic detector
const int R_MAGNETIC_PIN = A3;

// R step delay live in milliseconds
int stepDelayR = 5;

// R last step recorded
int lastStepR = 0;

// Current known rotation of head
int currentRotationOfHead = 0;

// Logical offset applied after homing R (Option A): home midpoint is treated as this angle
const int R_HOME_LOGICAL_OFFSET_DEG = 90;

// R Position from 0
volatile int motorStepPositionR = 0;

// Total steps compleated
volatile int motorStepCompletionR = 0;

// Steps per revolution
long R_stepsPerRevolution = 0;

// Steps for low window
int R_lowWindowSteps = 0;

long debugHomeX = 0;
long debugHomeY = 0;
long debugHomeZ = 0;

long debugDriftX = 0;
long debugDriftY = 0;
long debugDriftZ = 0;

// Math Functions
// ==============================

// Return if base 62
static inline bool isBase62Char(char c) {
  return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}

// Return if possible base 62
static inline bool looksBase62Id(const String& s, int off) {
  if (off < 0 || off + 5 > s.length()) return false;
  for (int i = 0; i < 5; ++i) {
    if (!isBase62Char(s.charAt(off + i))) return false;
  }
  return true;
}

// Map desired numeric delta -> which physical stepper direction to call
static inline int dirForDelta(long delta, int SIGN) {
  if (delta == 0) return 0;
  // If we need numeric position to increase (delta>0),
  // that's "forward" iff SIGN>0; else it's "backward".
  return ((delta > 0) == (SIGN > 0)) ? +1 : -1;
}

// Convert decimal to base 62
String decimalToBase62(unsigned long number, int minLength = 5) {
  const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  String result = "";

  if (number == 0) {
    result = "0";
  } else {
    while (number > 0) {
      result = chars[number % 62] + result;
      number /= 62;
    }
  }

  // Pad with leading zeros if needed
  while ((int)result.length() < minLength) {
    result = "0" + result;
  }

  return result;
}

// Decode base 62 to decimal
unsigned long base62ToDecimal(String input) {
  const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  unsigned long result = 0;

  for (int i = 0; i < input.length(); ++i) {
    char c = input.charAt(i);
    const char* pos = strchr(chars, c);

    if (pos == nullptr) {
      // Invalid character; handle however you like
      return 0;
    }

    int value = pos - chars;
    result = result * 62 + value;
  }

  return result;
}

// Convert numeric 0–61 to base-62 char
static inline char toBase62Digit(uint8_t v) {
  static const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  return chars[(v <= 61) ? v : 0];
}

// Convert base-62 char back to numeric 0–61 (returns 0xFF if invalid)
static inline uint8_t fromBase62Digit(char c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'Z') return 10 + (c - 'A');
  if (c >= 'a' && c <= 'z') return 36 + (c - 'a');
  return 0xFF;
}

// Pack up to 5 booleans into a single base-62 character.
char packBooleansToBase62(
  bool b1, bool b2 = false, bool b3 = false, bool b4 = false, bool b5 = false) {
  uint8_t bits =
    ((b1 ? 1 : 0) << 0) | ((b2 ? 1 : 0) << 1) | ((b3 ? 1 : 0) << 2) | ((b4 ? 1 : 0) << 3) | ((b5 ? 1 : 0) << 4);
  return toBase62Digit(bits);
}

// Unpack a base-62 character back into 5 booleans.
void unpackBooleansFromBase62(
  char c, bool& b1, bool& b2, bool& b3, bool& b4, bool& b5) {
  uint8_t bits = fromBase62Digit(c);
  if (bits == 0xFF) bits = 0;
  b1 = bits & (1 << 0);
  b2 = bits & (1 << 1);
  b3 = bits & (1 << 2);
  b4 = bits & (1 << 3);
  b5 = bits & (1 << 4);
}

// Work Functions
// ==============================

// Set data to be sent out
void sendOutData(String text) {
  
  // Update unique ID fpr payload
   lastMessageSentUniqueID += 1;

  // Assign final text to be sent out
    messageToServer = String(decimalToBase62((unsigned long)lastMessageSentUniqueID, 5)) + text;

  // Update last time we sent data out
  lastDataSend = millis();
}

// Switch check
void checkSwitch(){
  if (digitalRead(inputSwitch)) {

    // If switch off, turn on
    if (!lastSwitchRead) {

      lastSwitchChange = millis();
      lastSwitchRead = true;
      digitalWrite(actionLedPin, HIGH);
    }
  } else {

    // If switch on, turn off
    if (lastSwitchRead) {

      lastSwitchChange = millis();
      lastSwitchRead = false;
      digitalWrite(actionLedPin, LOW);
    }
  }
}

// Read digital magnetic index on R axis (A3 used as boolean)returns 0 when sensor is LOW
long readMagneticStrength(uint8_t samples = 8) {
  uint8_t lowCount = 0;
  for (uint8_t i = 0; i < samples; ++i) {
    if (digitalRead(R_MAGNETIC_PIN) == LOW) {
      lowCount++;
    }
  }
  // Majority LOW -> report 0, otherwise 1
  return (lowCount > (samples / 2)) ? 0L : 1L;
}

// Helper: true when the rotation index sensor is LOW (inside the window)
static inline bool isRotationIndexLow() {
  return (digitalRead(R_MAGNETIC_PIN) == LOW);
}

// Return true if the given lever is currently pressed
static inline bool leverPressedAxis(int pin, bool activeHigh) {
  int v = digitalRead(pin);
  return activeHigh ? (v == HIGH) : (v == LOW);
}

// Function to energize X stepper motor coils
bool stepMotorX(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  step = (step % 4 + 4) % 4;
  int direction = (step - lastStepX + 4) % 4;  // 1 = forward (toward lever), 3 = backward (away)

  bool moved = false;

  if (direction == 1) {  // forward (TOWARD lever) -> numeric position DECREASES
    if (!ignoreBounds && leverPressedAxis(PressureLever_ReadX, X_LEVER_ACTIVE_HIGH)) {
      sendOutData("EX lever pressed, block fwd");
      lastErrorReason = "X lever pressed; forward step blocked";
      return false;  // soft block: do not approach an already-pressed lever
    }
    if (ignoreBounds || motorStepPositionX > 0) {
      motorStepPositionX--;  // ↓ position toward lever
      moved = true;
    } else {
      sendOutData("EMotor X OOB fwd pos=" + String(motorStepPositionX));
      lastErrorReason = "Step Motor X ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

  } else if (direction == 3) {  // backward (AWAY from lever) -> numeric position INCREASES
    if (ignoreBounds || motorStepPositionX < maxXStep) {
      motorStepPositionX++;  // ↑ position away from lever
      moved = true;
    } else {
      sendOutData("EMotor X OOB back pos=" + String(motorStepPositionX) + " max=" + String(maxXStep));
      lastErrorReason = "Step Motor X ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

  } else if (direction == 2) {
    sendOutData("EMotor X invalid phase jump");
    lastErrorReason = "Invalid X phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // drive coils
  digitalWrite(IN1X, steps[step][0]);
  digitalWrite(IN2X, steps[step][1]);
  digitalWrite(IN3X, steps[step][2]);
  digitalWrite(IN4X, steps[step][3]);

  lastStepX = step;
  if (moved) motorStepCompletionX++;
  return true;
}

// Order Motor X forwards
bool stepMotorXForward(bool ignoreBounds) {
  int nextStep = (lastStepX + 1) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Order Motor X backwards
bool stepMotorXBackward(bool ignoreBounds) {
  int nextStep = (lastStepX + 3) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Function to energize Y stepper motor coils
bool stepMotorY(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  step = (step % 4 + 4) % 4;
  int direction = (step - lastStepY + 4) % 4;  // 1=fwd (toward lever), 3=back (away)

  bool moved = false;

  if (direction == 1) {  // forward (TOWARD lever) -> numeric position DECREASES
    if (!ignoreBounds && leverPressedAxis(PressureLever_ReadY, Y_LEVER_ACTIVE_HIGH)) {
      sendOutData("EY lever pressed, block fwd");
      lastErrorReason = "Y lever pressed; forward step blocked";
      return false;  // soft block
    }
    if (ignoreBounds || motorStepPositionY > 0) {
      motorStepPositionY--;  // ↓ position toward lever
      moved = true;
    } else {
      sendOutData("EMotor Y OOB fwd pos=" + String(motorStepPositionY));
      lastErrorReason = "Step Motor Y ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

  } else if (direction == 3) {  // backward (AWAY from lever) -> numeric position INCREASES
    if (ignoreBounds || motorStepPositionY < maxYStep) {
      motorStepPositionY++;  // ↑ position away from lever
      moved = true;
    } else {
      sendOutData("EMotor Y OOB back pos=" + String(motorStepPositionY) + " max=" + String(maxYStep));
      lastErrorReason = "Step Motor Y ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

  } else if (direction == 2) {
    sendOutData("EMotor Y invalid phase jump");
    lastErrorReason = "Invalid Y phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // drive coils
  digitalWrite(IN1Y, steps[step][0]);
  digitalWrite(IN2Y, steps[step][1]);
  digitalWrite(IN3Y, steps[step][2]);
  digitalWrite(IN4Y, steps[step][3]);

  lastStepY = step;
  if (moved) motorStepCompletionY++;
  return true;
}

// Order Motor Y forwards
bool stepMotorYForward(bool ignoreBounds) {
  int nextStep = (lastStepY + 1) % 4;
  return stepMotorY(nextStep, ignoreBounds);
}

// Order Motor Y backwards
bool stepMotorYBackward(bool ignoreBounds) {
  int nextStep = (lastStepY + 3) % 4;
  return stepMotorY(nextStep, ignoreBounds);
}

// Function to energize Z stepper motor coils
bool stepMotorZ(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  step = (step % 4 + 4) % 4;
  int direction = (step - lastStepZ + 4) % 4;  // 1=fwd (toward lever), 3=back (away)

  bool moved = false;

  if (direction == 1) {  // forward (TOWARD lever) -> numeric position DECREASES
    if (!ignoreBounds && leverPressedAxis(PressureLever_ReadZ, Z_LEVER_ACTIVE_HIGH)) {
      sendOutData("EZ lever pressed, block fwd");
      lastErrorReason = "Z lever pressed; forward step blocked";
      return false;  // soft block
    }
    if (ignoreBounds || motorStepPositionZ > 0) {
      motorStepPositionZ--;  // ↓ position toward lever
      moved = true;
    } else {
      sendOutData("EMotor Z OOB fwd pos=" + String(motorStepPositionZ));
      lastErrorReason = "Step Motor Z ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

  } else if (direction == 3) {  // backward (AWAY from lever) -> numeric position INCREASES
    if (ignoreBounds || motorStepPositionZ < maxZStep) {
      motorStepPositionZ++;  // ↑ position away from lever
      moved = true;
    } else {
      sendOutData("EMotor Z OOB back pos=" + String(motorStepPositionZ) + " max=" + String(maxZStep));
      lastErrorReason = "Step Motor Z ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

  } else if (direction == 2) {
    sendOutData("EMotor Z invalid phase jump");
    lastErrorReason = "Invalid Z phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // drive coils
  digitalWrite(IN1Z, steps[step][0]);
  digitalWrite(IN2Z, steps[step][1]);
  digitalWrite(IN3Z, steps[step][2]);
  digitalWrite(IN4Z, steps[step][3]);

  lastStepZ = step;
  if (moved) motorStepCompletionZ++;
  return true;
}

// Order Motor Z forwards
bool stepMotorZForward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 1) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Order Motor Z backwards
bool stepMotorZBackward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 3) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Function to energize R stepper motor coils
bool stepMotorR(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  step = (step % 4 + 4) % 4;
  int direction = (step - lastStepR + 4) % 4;  // 1=fwd (toward lever), 3=back (away)

  bool moved = false;

  if (direction == 1) {  // forward (TOWARD lever) -> numeric position DECREASES

    motorStepPositionR--;  // ↓ position toward lever
    moved = true;

  } else if (direction == 3) {  // backward  numeric position INCREASES

    motorStepPositionR++;  // ↑ position away from lever
    moved = true;

  } else if (direction == 2) {
    sendOutData("EMotor R invalid phase jump");
    lastErrorReason = "Invalid R phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // drive coils
  digitalWrite(IN1R, steps[step][0]);
  digitalWrite(IN2R, steps[step][1]);
  digitalWrite(IN3R, steps[step][2]);
  digitalWrite(IN4R, steps[step][3]);

  lastStepR = step;
  if (moved) motorStepCompletionR++;
  return true;
}

// Order Motor R forwards
bool stepMotorRForward(bool ignoreBounds) {
  int nextStep = (lastStepR + 1) % 4;
  return stepMotorR(nextStep, ignoreBounds);
}

// Order Motor R backwards
bool stepMotorRBackward(bool ignoreBounds) {
  int nextStep = (lastStepR + 3) % 4;
  return stepMotorR(nextStep, ignoreBounds);
}

// Change motor heat sink fans status
void runFans(bool run) {

  // Fans on, requested off
  if (heatSinkFansRunning && !run) {

    // Fans currently running
    heatSinkFansRunning = false;
    digitalWrite(ENABLE_PIN_FAN, LOW);

    // Change update
    lastFanChange = millis();

    // Fans off, requested to run
  } else if (!heatSinkFansRunning && run) {

    // Fans currently running
    heatSinkFansRunning = true;
    digitalWrite(ENABLE_PIN_FAN, HIGH);

    // Change update
    lastFanChange = millis();
  }
}

// Motors Running Status
void stepMotorsActivated(bool run) {
  unsigned long now = millis();
  unsigned long dt = now - LastMotorRunUpdate;

  if (run) {
    digitalWrite(ENABLE_PIN_MOTOR, HIGH);
    digitalWrite(ENABLE_PIN_MOTORY, HIGH);
    runFans(true);

    MotorUpTime += dt;
  } else {
    digitalWrite(ENABLE_PIN_MOTOR, LOW);
    digitalWrite(ENABLE_PIN_MOTORY, LOW);
    runFans(false);

    MotorDownTime += dt;
  }

  LastMotorRunUpdate = now;
}

// two-digit "ms" field: "XY" -> X.Y milliseconds (0.0..9.9)
static inline float parseTwoDigitMs(const String& s, int off = 0) {
  int d0 = s.charAt(off) - '0';
  int d1 = s.charAt(off + 1) - '0';
  if (d0 < 0 || d0 > 9 || d1 < 0 || d1 > 9) return 0.0f;
  return d0 + d1 * 0.1f;
}

// Return slot index [0..numCommands-1] that holds the payload id62, or -1 if absent
int findSlotById62(const String& id62) {
  for (int i = 0; i < numCommands; i++) {
    // Each command string starts with its 5-character base62 ID
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == id62) {
      return i;
    }
  }
  return -1;
}

// Count empty slots across ALL 20
int countEmptySlotsAll() {
  int c = 0;
  for (int i = 0; i < numCommands; i++)
    if (commands[i].length() == 0) c++;
  return c;
}

// Generic homing routine for one axis
static bool homeOneAxis(
  const char* axisName,
  int leverPin,
  int maxStep,
  int stepsPerInch,
  int stepDelayMs,
  bool (*stepForward)(bool),
  bool (*stepBackward)(bool),
  volatile int& stepPositionVar,
  volatile int& stepCompletionVar) {

  // Approach the switch (ignore bounds while seeking home)
  for (int i = 0; i < round(maxStep + (stepsPerInch)*2); ++i) {
    if (!stepForward(true)) {
      sendOutData(String("EHome ") + axisName + " step fwd fail");
      lastErrorReason = String("Home ") + axisName + " step forward failed";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(stepDelayMs);

    bool isZ = (leverPin == PressureLever_ReadZ);
    bool pressed = leverPressedAxis(leverPin, isZ ? Z_LEVER_ACTIVE_HIGH : X_LEVER_ACTIVE_HIGH);
    if (pressed) {
      // We hit the lever. Back off ~1 inch to clear it first…
      for (int j = 0; j < round(0.5 * stepsPerInch); ++j) {
        if (!stepBackward(true)) {
          sendOutData(String("EHome ") + axisName + " backoff fail");
          lastErrorReason = String("Home ") + axisName + " backoff failed";
          scriptErrorPaused = true;
          digitalWrite(errorLedPin, HIGH);
          return false;
        }
        delay(stepDelayMs);
      }

      pressed = leverPressedAxis(leverPin, isZ ? Z_LEVER_ACTIVE_HIGH : X_LEVER_ACTIVE_HIGH);
      if (pressed) {

        sendOutData(String("EHome ") + axisName + " lever stuck");
        lastErrorReason = String("Home ") + axisName + " lever still HIGH after backoff";
        scriptErrorPaused = true;
        digitalWrite(errorLedPin, HIGH);
        return false;
      }

      // ✅ Define zero *here*, at the cleared position.
      stepPositionVar = 0;
      stepCompletionVar = 0;
      return true;
    }
  }

  // Never triggered within travel
  sendOutData(String("EFailed to home ") + axisName);
  lastErrorReason = String("Home ") + axisName + " never triggered lever";
  scriptErrorPaused = true;
  digitalWrite(errorLedPin, HIGH);
  return false;
}

// Home the R (rotation) axis using the magnetic index on A1.
bool homeRotationAxisR() {
  // Home the R axis by finding the magnetic LOW window and centering within it.
  // Sensor: LOW == inside magnet window (see isRotationIndexLow()).
  // Strategy:
  //  1) Ensure we're OUTSIDE the LOW window (HIGH).
  //  2) Step forward until we ENTER the LOW window -> "entry".
  //  3) Continue stepping until we EXIT the LOW window -> "exit".
  //  4) Compute midpoint and move to it (slow / precise).
  //  5) Define midpoint as step=0 and measure steps/rev as midpoint->next midpoint.

  const long maxSearchSteps = 8000;   // safety for seeking edges
  const long maxRevSteps    = 40000;  // safety for measuring one revolution

  const int homeDelayMs = 6;          // requested slow homing speed (ms between steps)

  // 0) If we're currently inside the LOW window, move forward until we leave it.
  long guard = 0;
  while (isRotationIndexLow() && guard < maxSearchSteps) {
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R clear-low fail");
      lastErrorReason = "Home R: failed clearing LOW window";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);
    guard++;
  }
  if (guard >= maxSearchSteps) {
    sendOutData("EHome R stuck LOW");
    lastErrorReason = "Home R: sensor stuck LOW (couldn't clear window)";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // 1) Find the entry edge: HIGH -> LOW
  bool foundEntry = false;
  for (long i = 0; i < maxSearchSteps; ++i) {
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R seek entry fail");
      lastErrorReason = "Home R: step forward failed seeking entry";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);

    if (isRotationIndexLow()) {
      foundEntry = true;
      break; // now at first LOW position inside window
    }
  }

  if (!foundEntry) {
    sendOutData("EHome R no entry");
    lastErrorReason = "Home R: never entered LOW window";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // 2) Measure LOW window width (in steps).
  // We are currently at the first LOW step.
  long widthSteps = 1;
  for (long i = 0; i < maxSearchSteps; ++i) {
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R measure fail");
      lastErrorReason = "Home R: step forward failed measuring window";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);

    if (!isRotationIndexLow()) {
      // We just stepped onto first HIGH after the window.
      break;
    }
    widthSteps++;
  }

  if (widthSteps <= 0) widthSteps = 1;
  R_lowWindowSteps = (int)widthSteps;

  // We are now at FIRST HIGH after the window.
  // From ENTRY (first LOW) to this position is exactly widthSteps steps forward.
  const long exitPosFromEntry = widthSteps;

  // Midpoint offset from ENTRY (0-based inside LOW window)
  const long midOffset = widthSteps / 2;  // integer midpoint (works for even/odd widths)

  // 3) Move back from "first HIGH after window" to MIDPOINT.
  long backSteps = exitPosFromEntry - midOffset;
  for (long i = 0; i < backSteps; ++i) {
    if (!stepMotorRBackward(true)) {
      sendOutData("EHome R back to mid fail");
      lastErrorReason = "Home R: step backward failed moving to midpoint";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);
  }

  // Sanity: midpoint should be inside LOW window (or right at edge if width very small)
  if (!isRotationIndexLow()) {
    // If noise caused an off-by-one, nudge forward 1 step if that gets us LOW.
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R mid sanity fail");
      lastErrorReason = "Home R: failed midpoint sanity adjust";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);
  }

  // Define 0 at the midpoint of the LOW window
  motorStepPositionR = 0;
  motorStepCompletionR = 0;
  currentRotationOfHead = 0;

  // 4) Measure steps per revolution: MIDPOINT -> next MIDPOINT
  // Start at midpoint (likely LOW). First move to HIGH (exit window).
  long stepsToExit = 0;
  guard = 0;
  while (isRotationIndexLow() && guard < maxSearchSteps) {
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R exit fail");
      lastErrorReason = "Home R: step forward failed exiting window";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);
    stepsToExit++;
    guard++;
  }
  if (guard >= maxSearchSteps) {
    sendOutData("EHome R can't exit");
    lastErrorReason = "Home R: couldn't exit LOW window from midpoint";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // Then travel until we ENTER the LOW window again (next revolution)
  long stepsToNextEntry = 0;
  guard = 0;
  while (!isRotationIndexLow() && guard < maxRevSteps) {
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R to next entry fail");
      lastErrorReason = "Home R: step forward failed seeking next entry";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);
    stepsToNextEntry++;
    guard++;
  }
  if (guard >= maxRevSteps) {
    sendOutData("EHome R no next entry");
    lastErrorReason = "Home R: never saw LOW window again (no full revolution)";
    scriptErrorPaused = true;
    digitalWrite(errorLedPin, HIGH);
    return false;
  }

  // Now at next ENTRY (first LOW). Move forward midOffset steps to next midpoint.
  long stepsToNextMid = 0;
  for (long i = 0; i < midOffset; ++i) {
    if (!stepMotorRForward(true)) {
      sendOutData("EHome R to next mid fail");
      lastErrorReason = "Home R: step forward failed moving to next midpoint";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }
    delay(homeDelayMs);
    stepsToNextMid++;
  }

  // Total steps per revolution from midpoint -> next midpoint
  long stepsPerRev = stepsToExit + stepsToNextEntry + stepsToNextMid;
  if (stepsPerRev <= 0) stepsPerRev = 1;
  R_stepsPerRevolution = (int)stepsPerRev;

  // Return to logical 0 again
  motorStepPositionR = 0;
  motorStepCompletionR = 0;
  currentRotationOfHead = R_HOME_LOGICAL_OFFSET_DEG;

  return true;
}

// Home the Y axis by toggling only the Y enable pin
bool homeYAxisSoft() {

  // Turn only Y off, leave main ENABLE_PIN_MOTOR alone
  digitalWrite(ENABLE_PIN_MOTORY, LOW);
  delay(2000);  // let the mechanism settle to its rest/home position
  digitalWrite(ENABLE_PIN_MOTORY, HIGH);

  // Assume we are now at home = 0
  motorStepPositionY = 0;
  motorStepCompletionY = 0;
  debugHomeY = motorStepPositionY;

  return true;
}
// Homes Stepper Motors; returns true only if all succeed.
bool homeStepperMotorsPositions() {

  // Ensure motors are powered while homing
  stepMotorsActivated(true);
  checkSwitch();

  // Use your existing per-axis delays
  int useDelayX = stepDelayX > 0 ? stepDelayX : 4;
  int useDelayZ = stepDelayZ > 0 ? stepDelayZ : 4;

  // First, home X
  bool okX = homeOneAxis(
    "X",
    PressureLever_ReadX,
    maxXStep,
    arduinoMotorStepsPerInch,
    useDelayX,
    &stepMotorXForward,
    &stepMotorXBackward,
    motorStepPositionX,
    motorStepCompletionX);

  if (!okX) {
    stepMotorsActivated(false);
    return false;
  }

  checkSwitch();

  // Then, home Z
  bool okZ = homeOneAxis(
    "Z",
    PressureLever_ReadZ,
    maxZStep,
    arduinoMotorStepsPerInch,
    useDelayZ,
    &stepMotorZForward,
    &stepMotorZBackward,
    motorStepPositionZ,
    motorStepCompletionZ);

  if (!okZ) {
    stepMotorsActivated(false);
    return false;
  }

  checkSwitch();

  // Home rotation (R) using the magnetic index
  bool okR = homeRotationAxisR();

  if (!okR) {
    stepMotorsActivated(false);
    return false;
  }
  checkSwitch();

  // Finally, home Y using the "soft" enable-pin-only method
  bool okY = homeYAxisSoft();

  if (!okY) {
    stepMotorsActivated(false);
    return false;
  }
  checkSwitch();

  // Shut off motors if error occured
  if (!(okX && okZ && okR && okY)) {
    stepMotorsActivated(false);
  }

  // If all run, return as true or not, false
  return (okX && okZ && okR && okY);
}

// --- Request policy helpers ---
static inline unsigned long b62u(const String& s) {
  if (s.length() == 0) return 0xFFFFFFFFUL;  // treat empty as "no limit" later
  return base62ToDecimal(s);
}

// Does this ID exist in storage
static inline bool slotHasId62(const String& id62) {
  return findSlotById62(id62) >= 0;
}

// True if the next payload IDs are all absent
bool nextSlotsMissing() {
  for (int i = 0; i < 5; ++i) {
    String id62 = decimalToBase62((unsigned long)(currentCommandNumberID + i), 5);
    if (slotHasId62(id62)) return false;  // found one present -> not "all missing"
  }
  return true;
}

// Find the closest missing payload id
bool findClosestMissingId62(String& outId62, unsigned long maxN, bool windowOnly) {
  unsigned long cur = (unsigned long)currentCommandNumberID;
  unsigned long limit = windowOnly ? (cur + 5) : maxN;

  if (maxN != 0xFFFFFFFFUL && limit > maxN) limit = maxN;
  for (unsigned long n = cur; n <= limit; ++n) {
    String id62 = decimalToBase62(n, 5);
    if (!slotHasId62(id62)) {
      outId62 = id62;
      return true;
    }
  }
  return false;
}

// Main gate for deciding if we should queue a request now
void requestNextIfPolicy() {
  if (finishedCurrentGcode) return;
  if (millis() - lastPayloadRequestTime <= ImportantMsgDelay) return;
  if (millis() - lastPayloadRequestTime <= PayloadMsgDelay) return;

  const int empties = countEmptySlotsAll();
  const bool lotsAheadAllMissing = nextSlotsMissing();
  if (!(empties >= 14 || lotsAheadAllMissing)) return;

  unsigned long maxN = b62u(maxPayloadToRequest);
  if (maxN == 0xFFFFFFFFUL) {
    // No cap provided; set a very large ceiling
    maxN = 0xFFFFFFF0UL;
  }

  // Try to find the closest missing within the next-6 window first…
  String needId;
  bool found = findClosestMissingId62(needId, maxN, /*windowOnly=*/true);

  // If buffer is roomy search farther ahead up to maxN.
  if (!found && empties >= 14) {
    found = findClosestMissingId62(needId, maxN, /*windowOnly=*/false);
  }

  // Nothing missing in range up to maxN → either we’re loaded with all remaining
  if (!found) {
    return;
  }

  // Construct and queue the specific request
  String constructed = "R" + needId;

  sendOutData(constructed);
  lastPayloadRequestTime = millis();
  return;
}

// Execute individual command
bool executeCommand(String givenString) {
  // Task of command
  char task = givenString[0];

  // Info for task to be executed, if any
  String taskInfo = givenString.substring(1);

  // Pause script due to error
  if (task == 'A') {

    scriptErrorPaused = true;
    lastErrorReason = "Forced Into Error state by command";
    digitalWrite(errorLedPin, HIGH);
    return true;
  }

  // Unpause script due to error
  if (task == 'B') {

    scriptErrorPaused = false;
    digitalWrite(errorLedPin, LOW);
    return true;
  }

  // Put script into wait mode
  if (task == 'C') {

    scriptWait = true;
    return true;
  }

  // Remove script from wait mode
  if (task == 'D') {

    scriptWait = false;
    return true;
  }

  // Step motor X forward
  if (task == 'E') return stepMotorXForward(false);

  // Step motor X backward
  if (task == 'F') return stepMotorXBackward(false);

  // Step motor Z forward
  if (task == 'G') return stepMotorZForward(false);

  // Step motor Z backward
  if (task == 'H') return stepMotorZBackward(false);

  // Step motor X by relative step count
  if (task == 'I') {
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorXForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorXBackward(false)) return false;
        steps++;
      }
      delay((unsigned long)tempdelay);
    }
    return true;
  }

  // Step motor Z by relative step count
  if (task == 'J') {
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorZForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorZBackward(false)) return false;
        steps++;
      }
      delay((unsigned long)tempdelay);
    }
    return true;
  }

  // Hold all motor positions with force
  if (task == 'K') {
    if (taskInfo.length() != 0) {
      sendOutData("EK-length " + String(taskInfo));
      return false;
    }
    stepMotorsActivated(true);
    return true;
  }

  // Move motor X to specific step (LddXXXX where dd=ms, XXXX=base62 width 4)
  if (task == 'L') {
    if (taskInfo.length() != 6) {
      sendOutData("EL-length " + String(taskInfo));
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base62ToDecimal(taskInfo.substring(2, 6));  // 4 chars, 0..1,679,615
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxXStep) {
      while (motorStepPositionX != StepPosition) {
        long delta = (long)StepPosition - (long)motorStepPositionX;
        int dir = dirForDelta(delta, X_SIGN);
        if (dir > 0) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        delay((unsigned long)tempdelay);
      }

      return true;
    } else {
      sendOutData("EMotor X OOB (" + String(StepPosition) + ") max (" + String(maxXStep) + ")");
      return false;
    }
  }

  // Move motor Z to specific step (MddXXXX where dd=ms, XXXX=base62 width 4)
  if (task == 'M') {
    if (taskInfo.length() != 6) {
      sendOutData("EM-length " + String(taskInfo));
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base62ToDecimal(taskInfo.substring(2, 6));
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxZStep) {
      while (motorStepPositionZ != StepPosition) {
        long delta = (long)StepPosition - (long)motorStepPositionZ;
        int dir = dirForDelta(delta, Z_SIGN);
        if (dir > 0) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        delay((unsigned long)tempdelay);
      }

      return true;
    } else {
      sendOutData("EMotor Z OOB (" + String(StepPosition) + ") max (" + String(maxZStep) + ")");
      return false;
    }
  }

  // Ping back to server
  if (task == 'N') {
    if (taskInfo.length() != 0) {
      sendOutData("EN-length " + String(taskInfo));
      return false;
    }
    sendOutData("P(" + String(millis()) + ")");
    return true;
  }

  // Duel move X and Y motors O + [delay(2)] + [signPair(1)] + [x62(3)] + [z62(3)]
  if (task == 'O') {
    if (taskInfo.length() != 9) {
      sendOutData("EO-length " + String(taskInfo));
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

    float baseDelay = parseTwoDigitMs(taskInfo, 0);  // 0.0..9.9 ms
    char signPair = taskInfo.charAt(2);              // should be '0' for absolute
    if (signPair != '0') {
      // Not fatal—just note it. We ignore sign for absolute moves.
    }

    unsigned long xAbsUL = base62ToDecimal(taskInfo.substring(3, 6));  // width 3
    unsigned long zAbsUL = base62ToDecimal(taskInfo.substring(6, 9));  // width 3

    // Clamp within machine limits (your travel is tiny vs 62^3-1)
    long targetX = (long)min((unsigned long)maxXStep, xAbsUL);
    long targetZ = (long)min((unsigned long)maxZStep, zAbsUL);

    // Compute the required relative steps from current position
    long xSteps = targetX - (long)motorStepPositionX;
    long zSteps = targetZ - (long)motorStepPositionZ;

    // Bounds check (projected final positions)
    long projX = motorStepPositionX + xSteps;
    long projZ = motorStepPositionZ + zSteps;
    if (projX < 0 || projX > maxXStep || projZ < 0 || projZ > maxZStep) {
      sendOutData("EO-OOB x:" + String(motorStepPositionX) + "->" + String(projX) + " z:" + String(motorStepPositionZ) + "->" + String(projZ));
      lastErrorReason = "O move out of bounds";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

    // Parallel stepping so both axes finish together
    int ax = abs(xSteps), az = abs(zSteps);
    int maxSteps = (ax > az) ? ax : az;

    float xDelay = (ax == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)ax);
    float zDelay = (az == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)az);

    unsigned long nextX = millis(), nextZ = nextX;
    int remX = ax, remZ = az;

    // Use sign mapping so "forward" matches your configured axis convention
    int dirXCmd = dirForDelta(xSteps, X_SIGN);  // +1 => call stepMotorXForward
    int dirZCmd = dirForDelta(zSteps, Z_SIGN);  // +1 => call stepMotorZForward

    while (remX > 0 || remZ > 0) {
      unsigned long now = millis();

      if (remX > 0 && now >= nextX) {
        if (dirXCmd > 0) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        remX--;
        nextX = now + (unsigned long)(xDelay);
      }

      if (remZ > 0 && now >= nextZ) {
        if (dirZCmd > 0) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        remZ--;
        nextZ = now + (unsigned long)(zDelay);
      }

      delay(1);
    }

    return true;
  }

  // Rotate head to absolute angle 0–359°
  if (task == 'P') {
    // Expect exactly 2 base62 chars for the angle
    if (taskInfo.length() != 2) {
      sendOutData("EP-length " + String(taskInfo));
      return false;
    }

    // Decode angle (0..359)
    unsigned long angUL = base62ToDecimal(taskInfo);
    int angle = (int)(angUL % 360UL);
    if (angle < 0) angle += 360;  // just in case

    // Must have homed R first so stepsPerRev is known
    if (R_stepsPerRevolution <= 0) {
      sendOutData("EP-nohome");
      lastErrorReason = "Rotate R requested before homing (R_stepsPerRevolution<=0)";
      scriptErrorPaused = true;
      digitalWrite(errorLedPin, HIGH);
      return false;
    }

    // How many motor steps per degree
    double stepsPerDeg = (double)R_stepsPerRevolution / 360.0;

    // Absolute target step index for this angle (0..stepsPerRev-1)
    long targetStep = (long)llround(stepsPerDeg * (double)angle);

    // Current step index (0-based, maintained by stepMotorR*)
    long curStep = (long)motorStepPositionR;

    // Compute step delta and wrap to shortest path
    long deltaSteps = targetStep - curStep;
    long halfRev = R_stepsPerRevolution / 2;

    if (deltaSteps > halfRev) deltaSteps -= R_stepsPerRevolution;
    if (deltaSteps < -halfRev) deltaSteps += R_stepsPerRevolution;

    // Direction and magnitude
    int dir = (deltaSteps >= 0) ? +1 : -1;
    long stepsAbs = (deltaSteps >= 0) ? deltaSteps : -deltaSteps;

    // Step the R motor at the existing stepDelayR speed
    for (long i = 0; i < stepsAbs; ++i) {
      bool ok;
      if (dir > 0) {
        ok = stepMotorRForward(false);
      } else {
        ok = stepMotorRBackward(false);
      }
      if (!ok) {
        // stepMotorR has already set error state/message
        return false;
      }
      delay(stepDelayR);
    }

    // Update logical angle; keep it 0–359
    currentRotationOfHead = angle;

    return true;
  }

  // Home motors
  if (task == 'Q') {
    if (taskInfo.length() != 0) {
      sendOutData("EQ-length " + String(taskInfo));
      return false;
    }
    return homeStepperMotorsPositions();
  }

  // Move Y up (toward lever) until the lever is hit or max travel is reached
  // Format: Wdd where dd = 2-digit ms delay (e.g., "04" => 4 ms per step)
  if (task == 'R') {
    if (taskInfo.length() != 2) {
      sendOutData("EW-length " + String(taskInfo));
      return false;
    }

    float tempdelay = parseTwoDigitMs(taskInfo, 0);

    int steps = 0;
    while (!leverPressedAxis(PressureLever_ReadY, Y_LEVER_ACTIVE_HIGH) && steps < maxYStep) {
      if (!stepMotorYForward(false)) return false;
      delay((unsigned long)tempdelay);
      steps++;
    }

    return true;
  }

  // Move Y down (away from lever) back to home/original spot (stepPositionY == 0)
  // Format: Xdd where dd = 2-digit ms delay
  if (task == 'S') {
    if (taskInfo.length() != 2) {
      sendOutData("EX-length " + String(taskInfo));
      return false;
    }

    float tempdelay = parseTwoDigitMs(taskInfo, 0);

    int guard = 0;
    while (motorStepPositionY != 0 && guard < maxYStep) {
      long delta = (long)0 - (long)motorStepPositionY;
      int dir = dirForDelta(delta, Y_SIGN);  // map numeric delta to physical direction

      if (dir > 0) {
        if (!stepMotorYForward(false)) return false;
      } else {
        if (!stepMotorYBackward(false)) return false;
      }

      delay((unsigned long)tempdelay);
      guard++;
    }

    return true;
  }
  
  // Reset script for new gcode
  if (task == 'T') {
    // Expect exactly 5 chars: the last payload ID (base62) we're allowed to request
    if (taskInfo.length() != 5) {
      sendOutData("EQ-length " + String(taskInfo));
      return false;
    }
    // Optional: sanity check looks like base62
    if (!looksBase62Id(taskInfo, 0)) {
      sendOutData("EQ-badid " + taskInfo);
      return false;
    }

    // --- Reset run-state ---
    finishedCurrentGcode = false;
    scriptErrorPaused = false;
    scriptWait = false;

    // Set the global cap (DON'T shadow it locally)
    maxPayloadToRequest = taskInfo;  // e.g., "00AbZ" means don't request beyond this id

    // Reset execution pointers
    currentCommandNumberID = 1;
    currentCommandExecution = 0;
    currentCommandExecutionSlot = -1;

    // Clear any in-flight/queued requests & slots
    lastPayloadRequestTime = 0;
    for (int i = 0; i < numCommands; ++i) {
      commands[i] = "";
    }

    // Home first; on success, issue a ping as an important message
    if (homeStepperMotorsPositions()) {
      sendOutData("P(" + String(millis()) + ")");
      return true;
    } else {
      return false;
    }
  }

  // Disable motors
  if (task == 'U') {
    if (taskInfo.length() != 0) {
      sendOutData("EQ-length " + String(taskInfo));
      return false;
    }
    stepMotorsActivated(false);
    return true;
  }

  // Test all components
  if (task == 'V') {
    // No extra info allowed for now
    if (taskInfo.length() != 0) {
      sendOutData("EQ-length " + String(taskInfo));
      return false;
    }

    // Make sure motors are enabled for the test
    stepMotorsActivated(true);

    // -----------------------------
    // 1) LEVER TEST (X/Y/Z)
    // -----------------------------
    bool xHit = false;
    bool yHit = false;
    bool zHit = false;

    unsigned long lastBlink = millis();
    bool blinkState = false;

    // Blink while waiting for all levers to be pressed at least once
    while (!(xHit && yHit && zHit)) {
      // Read lever states
      if (leverPressedAxis(PressureLever_ReadX, X_LEVER_ACTIVE_HIGH)) xHit = true;
      if (leverPressedAxis(PressureLever_ReadY, Y_LEVER_ACTIVE_HIGH)) yHit = true;
      if (leverPressedAxis(PressureLever_ReadZ, Z_LEVER_ACTIVE_HIGH)) zHit = true;

      // Blink indicator LED so you know it's waiting
      unsigned long now = millis();
      if (now - lastBlink >= 250) {
        blinkState = !blinkState;
        digitalWrite(actionLedPin, blinkState ? HIGH : LOW);
        lastBlink = now;
      }

      // Bail out if some other part of the script forced an error
      if (scriptErrorPaused) {
        digitalWrite(actionLedPin, LOW);
        lastErrorReason = "Task V aborted: scriptErrorPaused set";
        return false;
      }
    }

    // All levers seen at least once
    digitalWrite(actionLedPin, HIGH);
    delay(200);
    digitalWrite(actionLedPin, LOW);

    // -----------------------------
    // 2) HOME ALL AXES
    // -----------------------------
    if (!homeStepperMotorsPositions()) {
      // homeStepperMotorsPositions() sets lastErrorReason
      return false;
    }

    // Snapshot home positions for drift measurement
    debugHomeX = motorStepPositionX;
    debugHomeY = motorStepPositionY;
    debugHomeZ = motorStepPositionZ;

    // -----------------------------
    // 3) TRAVEL / DRIFT TEST (SQUARE LOOPS)
    // -----------------------------

    int margin = arduinoMotorStepsPerInch;
    int maxTestX = maxXStep - margin;
    int maxTestZ = maxZStep - margin;
    if (maxTestX < 0) maxTestX = maxXStep;
    if (maxTestZ < 0) maxTestZ = maxZStep;

    // Different speeds to test (in ms per step)
    const int numSpeeds = 2;
    int speeds[numSpeeds] = { 4, 2 };  // tweak as you like

    const int loopsPerSpeed = 5;  // how many squares per speed

    for (int si = 0; si < numSpeeds; ++si) {
      int stepDelayMs = speeds[si];

      for (int loop = 0; loop < loopsPerSpeed; ++loop) {
        // Move to (maxTestX, 0)
        while (motorStepPositionX != maxTestX) {
          long delta = (long)maxTestX - (long)motorStepPositionX;
          int dir = dirForDelta(delta, X_SIGN);
          if (dir > 0) {
            if (!stepMotorXForward(false)) return false;
          } else {
            if (!stepMotorXBackward(false)) return false;
          }
          delay(stepDelayMs);
        }

        // Move to (maxTestX, maxTestZ)
        while (motorStepPositionZ != maxTestZ) {
          long delta = (long)maxTestZ - (long)motorStepPositionZ;
          int dir = dirForDelta(delta, Z_SIGN);
          if (dir > 0) {
            if (!stepMotorZForward(false)) return false;
          } else {
            if (!stepMotorZBackward(false)) return false;
          }
          delay(stepDelayMs);
        }

        // Move to (0, maxTestZ)
        while (motorStepPositionX != 0) {
          long delta = (long)0 - (long)motorStepPositionX;
          int dir = dirForDelta(delta, X_SIGN);
          if (dir > 0) {
            if (!stepMotorXForward(false)) return false;
          } else {
            if (!stepMotorXBackward(false)) return false;
          }
          delay(stepDelayMs);
        }

        // Move back to (0, 0) (home)
        while (motorStepPositionZ != 0) {
          long delta = (long)0 - (long)motorStepPositionZ;
          int dir = dirForDelta(delta, Z_SIGN);
          if (dir > 0) {
            if (!stepMotorZForward(false)) return false;
          } else {
            if (!stepMotorZBackward(false)) return false;
          }
          delay(stepDelayMs);
        }
      }

      // After finishing all loops at this speed, measure drift from home
      debugDriftX = (long)motorStepPositionX - debugHomeX;
      debugDriftZ = (long)motorStepPositionZ - debugHomeZ;
      // (debugDriftY is left for future Y-axis tests if you want them)
    }

    // Final blink and message back to Roblox/host
    digitalWrite(actionLedPin, HIGH);
    delay(200);
    digitalWrite(actionLedPin, LOW);

    sendOutData("VDone homeX=" + String(debugHomeX) + " homeZ=" + String(debugHomeZ) + " driftX=" + String(debugDriftX) + " driftZ=" + String(debugDriftZ));

    return true;
  }

  // Unknown command fallback
  sendOutData("EUnknown command: " + String(task));
  digitalWrite(errorLedPin, HIGH);
  return false;
}

// Able to execute next command in a string of commands
String getNextSection(String input) {
  // Skip 5-char payload ID
  input = input.substring(5);

  int sectionIndex = 0;
  int start = 0;

  while (true) {
    int end = input.indexOf(';', start);

    if (sectionIndex == currentCommandExecution) {
      // If there's a ';', return [start, end)
      if (end != -1) return input.substring(start, end);
      // No more ';' — if there's remaining text, treat it as the last command
      if (start < input.length()) return input.substring(start);
      // Nothing left
      return "";
    }

    // Not our section yet; advance
    if (end == -1) return "";  // ran out of sections
    sectionIndex++;
    start = end + 1;
  }
}

// Send and execute next command or request next payload if needed
void runCommands() {
  if (scriptErrorPaused || scriptWait) return;

  // If we have a selected slot with a payload, try to execute next command
  if (currentCommandExecutionSlot >= 0 && currentCommandExecutionSlot < numCommands && commands[currentCommandExecutionSlot].length() >= 5) {

    String input = commands[currentCommandExecutionSlot];
    String nextCommand = getNextSection(input);

    if (nextCommand != "") {

      if (executeCommand(nextCommand)) {
        currentCommandExecution++;
        } else {
    // Unconditionally enter error/pause mode on any command failure
    String reason = lastErrorReason.length() ? lastErrorReason : "executeCommand returned false";
  }

  return;  // next loop iteration will continue from the updated indices
}// Payload finished: clear & move to the next payload number
    commands[currentCommandExecutionSlot] = "";
    currentCommandNumberID += 1;
    currentCommandExecution = 0;

    unsigned long maxN = b62u(maxPayloadToRequest);
    if (maxN != 0xFFFFFFFFUL) {
      unsigned long justFinished = (unsigned long)(currentCommandNumberID - 1);
      // Gcode Finished
      if (justFinished == maxN) {
        finishedCurrentGcode = true;

      }
    }
    // fall-through to selection/request for the new currentCommandNumberID
  }

  // Select the slot that holds the current payload, if any
  String needId = decimalToBase62((unsigned long)currentCommandNumberID, 5);
  int slot = -1;
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == needId) {
      slot = i;
      break;
    }
  }
  if (slot >= 0) {
    if (currentCommandExecutionSlot != slot) {
      currentCommandExecutionSlot = slot;

    }
    return;  // we’ll execute it on the next loop iteration
  }

  // Request next payload
  requestNextIfPolicy();
}

// Send bulk data
// Send bulk data
void sendBulkData() {
  if (millis() > lastDataSend + 2800 && millis() > LastImportantMsgSend + ImportantMsgDelay) {

    unsigned long now = millis();
    unsigned long dt = now - LastMotorRunUpdate;  // how long since we last accounted
    if (dt > 0) {
      bool motorsOn = (digitalRead(ENABLE_PIN_MOTOR) == HIGH);
      if (motorsOn) {
        MotorUpTime += dt;  // add to uptime
      } else {
        MotorDownTime += dt;  // add to downtime
      }
      LastMotorRunUpdate = now;  // reset the cursor
    }

    // Flags packed into 1 base62 digit
    char packedFlags = packBooleansToBase62(
      scriptErrorPaused,
      scriptWait,
      finishedCurrentGcode,
      digitalRead(ENABLE_PIN_MOTOR),
      digitalRead(ENABLE_PIN_FAN));

    // base-62 telemetry – clamp to [0, maxStep] and avoid negative wrap
    auto clampPos = [](volatile int pos, int maxStep) -> unsigned long {
      long p = pos;
      if (p < 0) p = 0;
      if (p > maxStep) p = maxStep;
      return (unsigned long)p;
    };

    unsigned long xPosSafe = clampPos(motorStepPositionX, maxXStep);
    unsigned long yPosSafe = clampPos(motorStepPositionY, maxYStep);
    unsigned long zPosSafe = clampPos(motorStepPositionZ, maxZStep);

    String xPos62 = decimalToBase62(xPosSafe, 3);
    String xTot62 = decimalToBase62((unsigned long)motorStepCompletionX, 4);

    String yPos62 = decimalToBase62(yPosSafe, 3);
    String yTot62 = decimalToBase62((unsigned long)motorStepCompletionY, 4);

    String zPos62 = decimalToBase62(zPosSafe, 3);
    String zTot62 = decimalToBase62((unsigned long)motorStepCompletionZ, 4);

    String rTot62 = decimalToBase62((unsigned long)motorStepCompletionR, 4);

    // Last executed pointer (7 chars: 5 + 2 base62)
    String lastExec =
      String(decimalToBase62((unsigned long)currentCommandNumberID, 5)) +
      String(decimalToBase62((unsigned long)currentCommandExecution, 2));

    // Uptime/downtime → deciseconds → base62 width 3 (clamped to 62^3-1)
    const unsigned long B62_3_MAX = 62UL * 62UL * 62UL - 1UL;  // 238,327
    unsigned long up_ds = (MotorUpTime / 100UL);
    if (up_ds > B62_3_MAX) up_ds = B62_3_MAX;
    unsigned long down_ds = (MotorDownTime / 100UL);
    if (down_ds > B62_3_MAX) down_ds = B62_3_MAX;
    String up62 = decimalToBase62(up_ds, 3);
    String down62 = decimalToBase62(down_ds, 3);

    // Assemble payload (x y z r order)
    String payload =
       String(packedFlags) + ";" +  // 1 flags

      String((int)digitalRead(PressureLever_ReadX)) + ";" +   // 2 X lever
      xPos62 + ";" +                                          // 3 X pos
      xTot62 + ";" +                                          // 4 X total

      String((int)digitalRead(PressureLever_ReadY)) + ";" +   // 5 Y lever
      yPos62 + ";" +                                          // 6 Y pos
      yTot62 + ";" +                                          // 7 Y total

      String((int)digitalRead(PressureLever_ReadZ)) + ";" +   // 8 Z lever
      zPos62 + ";" +                                          // 9 Z pos
      zTot62 + ";" +                                          // 10 Z total

      String((int)digitalRead(R_MAGNETIC_PIN)) + ";" +        // 11 R magnetic
      String(currentRotationOfHead) + ";" +                   // 12 R rotation
      rTot62 + ";" +                                          // 13 R total

      up62 + ";" +                                            // 14 uptime
      down62 + ";" +                                          // 15 downtime
      lastExec;                                               // 16 last exec


    sendOutData(payload);
    lastDataSend = millis();
  }
}

// Send priority message
bool sendImportantData() {
  if (messageToServer != "") {

    String wireLine =
      "B" + messageToServer + ";" + String(decimalToBase62((unsigned long)currentCommandExecutionSlot, 5)) + String(decimalToBase62((unsigned long)currentCommandExecution, 2));

    // Send data out
   sendOutData(wireLine);

    // Update the time we last sent out this
    LastImportantMsgSend = millis();
    return true;
  }
  return false;
}

// Store one payload chunk body (NO leading 'S') into commands[].
// body format: <5-char base62 ID> + <payload text...>
void storePayloadBody_NoLeadingS(String body) {
  body.trim();

  // Must be at least 6 chars: 5-char ID + at least 1 command char (or ';')
  if (body.length() < 6) {
    sendOutData("EStore-short");
    return;
  }

  // First 5 chars must be base62 id
  if (!looksBase62Id(body, 0)) {
    sendOutData("EStore-badid");
    return;
  }

  String p62 = body.substring(0, 5);

  // Choose existing slot (same id) or first free
  int slot = -1;
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() >= 5 && commands[i].substring(0, 5) == p62) {
      slot = i;
      break;
    }
    if (slot == -1 && commands[i].length() == 0) slot = i;
  }

  if (slot == -1) {
    sendOutData("ECommand storage full");
    return;
  }

  commands[slot] = body;  // stored WITHOUT 'S'

  // If this is exactly the payload we need next, select it
  if ((int)base62ToDecimal(p62) == currentCommandNumberID) {
    currentCommandExecutionSlot = slot;
    currentCommandExecution = 0;
  }
}

// Read incoming string from server
void handleInboundLine(String in) {
  in.trim();
  if (!in.length()) return;

  lastDataIn = millis();

  // Immediate execution
  if (in.charAt(0) == 'I') {
    currentCommandInstantExecution = true;
    bool ok = executeCommand(in.substring(1));
    currentCommandInstantExecution = false;
    if (!ok) {
      //Error
    }
    return;
  }

  // Single payload chunk
  if (in.charAt(0) == 'S') {
    String body = in.substring(1);   // STRIP 'S'
    body.trim();
    if (body.length() > 64) {
      sendOutData("EChunkTooLong");
      return;
    }
    storePayloadBody_NoLeadingS(body);
    return;
  }

  // Direct command
  bool ok = executeCommand(in);
  if (!ok) {
//Error
  }
}

// Check communication to send out
void checkCommunication() {
  // Attempt Important data send, if none, attempt bulk data
  if (!sendImportantData()) {
    sendBulkData();
  }
}

// Message sent to arduino
void onMessageToArduinoChange() {
  String msg = messageToArduino;
  msg.trim();
  if (!msg.length()) return;

  // Non-payload → execute immediately
  if (msg.charAt(0) != 'S') {
    handleInboundLine(msg);
    return;
  }

  // Payload bundle: S or S$
  int start = (msg.length() >= 2 && msg.charAt(1) == '$') ? 2 : 1;
  String buf = msg.substring(start);
  buf.trim();

  while (buf.length()) {
    int bar = buf.indexOf('|');
    String token = (bar < 0) ? buf : buf.substring(0, bar);
    buf = (bar < 0) ? "" : buf.substring(bar + 1);

    token.trim();
    if (!token.length()) continue;

    if (token.length() > 64) {
      sendOutData("EChunkTooLong");
      return;
    }

    storePayloadBody_NoLeadingS(token);
  }
}

// Required Empty function for server message change
void onMessageToServerChange() {
}

// Set up script
void setup() {

    // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  // Update switch reading to current position
  lastSwitchRead = digitalRead(inputSwitch);

  // Set control X pins as outputs
  // =============================

  pinMode(IN1X, OUTPUT);
  pinMode(IN2X, OUTPUT);
  pinMode(IN3X, OUTPUT);
  pinMode(IN4X, OUTPUT);
  pinMode(PressureLever_ReadX, INPUT);

  // Set control Y pins as outputs
  // ==============================

  pinMode(IN1Y, OUTPUT);
  pinMode(IN2Y, OUTPUT);
  pinMode(IN3Y, OUTPUT);
  pinMode(IN4Y, OUTPUT);
  pinMode(PressureLever_ReadY, INPUT);

  // Set control Z pins as outputs
  // ==============================

  pinMode(IN1Z, OUTPUT);
  pinMode(IN2Z, OUTPUT);
  pinMode(IN3Z, OUTPUT);
  pinMode(IN4Z, OUTPUT);
  pinMode(PressureLever_ReadZ, INPUT);

  // Set control R pins as outputs
  // ==============================

  pinMode(IN1R, OUTPUT);
  pinMode(IN2R, OUTPUT);
  pinMode(IN3R, OUTPUT);
  pinMode(IN4R, OUTPUT);
  pinMode(R_MAGNETIC_PIN, INPUT);

  // Output pins
  // ==============================

  pinMode(ENABLE_PIN_MOTOR, OUTPUT);
  pinMode(ENABLE_PIN_MOTORY, OUTPUT);
  pinMode(ENABLE_PIN_FAN, OUTPUT);
  pinMode(ENABLE_PIN_GUNMOTOR, OUTPUT);
  pinMode(inputSwitch, INPUT);

  // Set light pins as outputs
  pinMode(wifiLedPin, OUTPUT);
  pinMode(runLedPin, OUTPUT);
  pinMode(commLedPin, OUTPUT);
  pinMode(actionLedPin, OUTPUT);
  pinMode(errorLedPin, OUTPUT);

  // Script running LED
  digitalWrite(runLedPin, HIGH);

// Alert server that arduino is active
 sendOutData("SScript Running");
}

// Main ongoing script loop
void loop() {

  // Delay to prevent loop spam
  delay(5);

  // Update Cloud
  ArduinoCloud.update();
  
  // Error if not WiFi connected
  if (!ArduinoCloud.connected()) {
    
    digitalWrite(wifiLedPin, HIGH);
    delay(200);
    digitalWrite(wifiLedPin, LOW);
    delay(150);
  } else {
    
    digitalWrite(wifiLedPin, LOW);
  }

  // Check if switch was changed
  checkSwitch();

  // Process incoming packets & queued bulk updates
  checkCommunication();

  // Turn on led if communication from server has been too long
  if (lastDataIn + 35000 < millis()) {

    digitalWrite(commLedPin, HIGH);
  } else {

    digitalWrite(commLedPin, LOW);
  }

  // Run commands if possible
  if (!scriptErrorPaused && !scriptWait && !finishedCurrentGcode && !lastSwitchRead) {
    runCommands();
  }
}
